/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 8.0.27 : Database - mybatis
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`mybatis` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `mybatis`;

/*Table structure for table `tablechoose` */

DROP TABLE IF EXISTS `tablechoose`;

CREATE TABLE `tablechoose` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '1951000',
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '第五单元',
  `ctitle` varchar(500) DEFAULT NULL,
  `choosea` varchar(500) DEFAULT NULL,
  `chooseb` varchar(500) DEFAULT NULL,
  `choosec` varchar(500) DEFAULT NULL,
  `choosed` varchar(500) DEFAULT NULL,
  `answer` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT 'b',
  `answerright` varchar(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tablechoose` */

insert  into `tablechoose`(`id`,`unit`,`ctitle`,`choosea`,`chooseb`,`choosec`,`choosed`,`answer`,`answerright`) values ('1951000','第一单元','在下列概念中，Java语言只保留了______。','A.运算符重载	','B.方法重载','C.指针	','	D.结构和联合','b',NULL),('1951000','第一单元','下列关于Java语言特性的描述中，错误的是______。','A.支持多线程操作','B.Java程序与平台无关','C.Java程序可以直接访问Internet上的对象','D.支持单继承和多继承','b',NULL),('1951000','第一单元','下列关于Java Application程序结构特点的描述中，错误的是______。','A.Java程序是由一个或多个类组成的','B.组成Java程序的若干个类可以放在一个文件中，也可以放在多个文件中','C.Java程序的文件名要与某个类名相同','D.组成Java程序的多个类中，有且仅有一个主类','b',NULL),('1951000','第一单元','Java程序经过编译后生成的文件的后缀是______。','A..obj	','B..exe	','C..class','D..java','b',NULL),('1951000','第一单元','下列关于运行字节码文件的命令行参数的描述中，正确的是______。','A.第一个命令行参数（紧跟命令字的参数）被存放在args[0]中','B.数组args[]的大小与命令行参数的个数无关','C.第一个命令行参数被存放在args[1]中','D.命令行的命令字被放在args[0]中','b',NULL),('1951000','第二单元','Java语言所用的字符集中字符是__________位。','A.8','B.16	','C.32	','D.64','b',NULL),('1951000','第二单元','2-2下列关于标识符的描述中，正确的是_________。','A.标识符中可以使用下画线和美元符','B.标识符中可以使用连接符和井号符','C.标识符中大小写字母是无区别的','D.标识符可选用关键字','b',NULL),('1951000','第二单元','Java语言的各种分隔符中，非法的是_________。','A.空白符','B.分号	','C.逗号	','D.问号','b',NULL),('1951000','第二单元','下列是Java语言中可用的注释符，其中错误的是_________。','A.//	','B./*…*/','C./**…**/','D./**…**/','b',NULL),('1951000','第二单元','Java语言中字符型数据的长度是_________位。','A.8	','B.16	','C.32	','D.64','b',NULL),('1951000','第二单元','下列描述的两种数据类型的长度不相等的是_________。','A.字符型和布尔型','B.字节型和布尔型','C.短整型和字符型	','D.整型和单精度浮点型','b',NULL),('1951000','第二单元','下列是Java语言中的复合数据类型，其中错误的是_________。','A.数组','B.接口','C.枚举','D.类','b',NULL),('1951000','第二单元','下面是关于Java语言中数据类型的强制转换的描述，其中错误的是_________。','A.当数据类型从高转换为低时需要强制转换','B.强制转换时使用强制转换运算符，形如（（类型））','C.浮点型数据强制转换为整型时，小数部分四含五入','D.赋值操作中都要采用强制类型','b',NULL),('1951000','第二单元','下列关于定义符号常量的描述中，错误的是_________。','A.定义符号常量使用关键字const','B.定义符号常量时要赋初值','C.符号常量既可定义为类成员，又可在方法中定义','D.定义符号常量时必须给出数据类型','b',NULL),('1951000','第二单元','下列关于变量的默认值的描述，其中错误的是_________。','A.定义变量而没有进行初始化时，该变量具有默认值','B.字符型变量的默认值为换行符','C.布尔型变量的默认值为true法','D.变量的默认值是可以被改变的','b',NULL),('1951000','第二单元','下列关于变量定义的描述中，正确的是_________。','A.定义变量时至少应指出变量名字和类型','B.定义变量时没有给出初值，该变量可能是无意义值','C.定义变量时，同一个类型多个变量间可用逗号分隔','D.定义变量时必须要给变量初始化','b',NULL),('1951000','第二单元','下列关于变量作用域的描述，错误的是_________。','A.在某个作用域定义的变量，仅在该作用域内是可见的，而在该作用域外是不可见的','B.在类中定义的变量的作用域在类体内，该类中的方法内可以使用','C.在方法中定义的变量的作用域仅在该方法体内','D.在方法中作用域可嵌套，在嵌套的作用域中可以定义同名变量','b',NULL),('1951000','第二单元','下列关于增1（++）减1（--）运算符的描述中，正确的是_________。','A.增1减1运算符都是单目运算符','B.增1减1运算符都具有前缀运算和后缀运算','C.增1减1运算符不会改变变量的值','D.增1减1运算符前缀运算和后缀运算后表达式值是相同的','b',NULL),('1951000','第二单元','下列关于运算符优先级的描述中，错误的是_________。','A.在表达式中，优先级高的运算符先进行计算','B.赋值运算符优先级最低','C.单目运算符优先级高于双目和三目运算符','D.逻辑运算符优先级高于逻辑位运算符','b',NULL),('1951000','第二单元','下列关于表达式的描述中，正确的是_________。','A.任何表达式都有确定的值和类型','B.算术表达式的类型由第一个操作数的类型决定','C.逻辑表达式的操作数是逻辑型的','D.赋值表达式的类型取决于右值表达式的类型','b',NULL),('1951000','第二单元','下列表达式中，非法的是_________。','A.a+c+++d ','B.（a+c）--	','C.c<<b','D.a！=b？c:d','b',NULL),('1951000','第二单元','下列关于条件语句的描述中，错误的是_________。','A.if语句可以有多个else子句和else if子句','B.if语句中可以没有else子句和else if子句','C.i任语句中的（条件可以使用任何表达式','D.if语句的if体、else体内可以有循环语句','b',NULL),('1951000','第二单元','下列关于开关语句的描述中，错误的是_________。','A.开关语句中，default子句可以省略','B.开关语句中，case子句的（语句序列）中一定含有break语句','C.开关语句中，case子句和default子句都可以有多个','D.退出开关语句的唯一条件是执行break语句','b',NULL),('1951000','第二单元','下列关于循环语句的描述中，错误的是_________。','A.任何一种循环体内都可以包含一种循环语句','B.循环体可以是空语句，也可以是空','C.循环体内可以出现多个break语句','D.循环语句中，循环体至少被执行一次','b',NULL),('1951000','第二单元','下列循环语句中，循环体被执行的次数为_________。','A.3	','B.4','C.不确定	','D.无限','b',NULL),('1951000','第三单元','下列对封装性的描述中，错误的是_________。','A.封装体包含了属性和行为','B.封装体中的属性和行为的访问权限是相同的','C.被封装的某些信息在封装体外是不可见的','D.封装使得抽象的数据类型提高了可重用性','b',NULL),('1951000','第三单元','下列关于继承性的描述中，错误的是_________。','A.一个类可以同时生成多个子类','B.子类继承了父类的所有成员','C.Java语言支持单重继承和多重继承','D.Java语言通过接口可使子类使用多个父类的成员','b',NULL),('1951000','第三单元','下列对多态性的描述中，错误的是_________。','A.Java语言允许运算符重载','B.Java语言允许方法重载','C.Java语言允许变量覆盖','D.多态性提高了程序的抽象性和简洁性','b',NULL),('1951000','第三单元','在类的修饰符中，规定只能被同一包类所使用的修饰符是_________。','A.public','B.默认','C.final	','D.abstract','b',NULL),('1951000','第三单元','在成员变量的修饰符中，规定只允许该类自身访问的修饰符是_________。','A.private	','B.public	','C.默认	','D.protected','b',NULL),('1951000','第三单元','在成员方法的访问控制修饰符中，规定访问权限包含该类自身、同包的其他类','A.public','B.private','C.默认','D.protected','b',NULL),('1951000','第三单元','下列关于构造方法的特点的描述中，错误的是_________。','A.不可重载','B.方法名同类名','C.无返回类型','D.系统自动调用','b',NULL),('1951000','第三单元','下列关于静态方法的描述中，错误的是_________。','A.在类体内说明静态方法使用关键字static','B.静态方法只能处理静态变量或调用静态方法','C.静态方法不占用对象的内存空间，非静态方法占用对象的内存空间','D.静态方法只能用类名调用','b',NULL),('1951000','第三单元','下列对静态初始化器的描述中，错误的是_________。','A.静态初始化器是用来对类进行初始化的，而不是对某个对象初始化','B.静态初始化器是由关键字static和一对花括号组成的语句组','C.静态初始化器不同于构造方法，它不是方法','D.静态初始化器是产生新对象时，由系统自动调用的','b',NULL),('1951000','第三单元','下列关于抽象类的描述中，错误的是_________。','A.抽象类是用修饰符abstract 说明的','B.抽象类是不可以定义对象的','C.抽象类是不可以有构造方法的','D.抽象类通常要有它的子类','b',NULL),('1951000','第三单元','下列关于类的继承性的描述中，错误的是_________。','A.继承是在已有类的基础上生成新类的一种方法','B.子类继承父类的所有成员','C.Java语言要求一个子类只有一个父类','D.父类中成员的访问权限在子类中将被改变','b',NULL),('1951000','第三单元','下列关于子类继承父类的成员的描述中，错误的是_________。','A.子类中继承父类中的所有成员都可以直接访问','B.子类中定义有与父类同名变量时，子类继承父类的操作中，使用继承父类的变量；子类执行自己的操作中，使用自己定义的变量','C.当子类中出现成员方法头与父类方法头相同的方法时，子类成员方法霜盖父米中','D.方法重载是编译时处理的，而方法覆盖是在运行时处理的','b',NULL),('1951000','第三单元','下列关于接口的描述中，错误的是_________。','A.接口实际上是由常量和抽象方法构成的特殊类','B.一个类只允许继承一个接口','C.定义接口使用的关键字是interface','D.在继承接口的类中通常要给出接口中定义的抽象方法的具体实现','b',NULL),('1951000','第三单元','下列关于包的描述中，错误的是_________。','A.包是一种特殊的类','B.包是若干个类的集合','C.包是使用package语句创建的','D.包有有名包和无名包两种','b',NULL),('1951000','第三单元','下列常用包中，存放用户图形界面类库的包是_________。','A.java.awt','B.java, lang','C. java, util','D.javn.io','b',NULL),('1951000','第三单元','下列是系统提供的常用的类，是所有类的父类的类是_________。','A.Math','B.Object','C.System	','D.String','b',NULL),('1951000','第四单元','Applet类是属于______包的。','A.java.awt','B.java.applet','C.java.io','D.java.lang','b',NULL),('1951000','第四单元','下列关于Applet程序的描述中，错误的是______。','A.Applet程序的主类必须是Applet类的子类','B.Applet程序的主类中应有一个main（）方法','C.Applet不是完整的独立程序','D.Applet的字节码文件必须嵌套在一个HTML文件中','b',NULL),('1951000','第四单元','下列关于Applet程序的描述中，错误的是______。','A.将编辑好的Java源文件，使用javac命令生成字节码文件','B.将字节码文件嵌入HTML文件，并存放在一个Web服务器中','C.使用浏览器解释HTML文件中的标记','D.使用编译器直接执行嵌套在HTML文件中的字节码文件','b',NULL),('1951000','第四单元','在Applet类的主要方法中，用来实现初始化操作的是______。','A.init（）','B.stop（）','C.start（）','D.paint（）','b',NULL),('1951000','第四单元','下列关于HTML文件的描述中，错误的是______。','A.日TML.文件是使用一种超文本标记语言（HTML）书写的文件','B.HTML.文件中使用的标记通常是用一对尖括号括起的，两个标记之间是正文内容','C.HTML文件中没有单独出现的标记','D.HTML中不区分大小写字母','b',NULL),('1951000','第四单元','下列关于向Applet程序传递参数的描述中，错误的是______。','A.Applet程序可以通过命令行获取外部参数','B.Applet程序可以通过HTML文件获取外部参数','C.使用Applet标记中的PARAM标志来实现','D.Applet程序中使用get Parameter（）方法读取参数值','b',NULL),('1951000','第四单元','下列关于字体的描述中，错误的是______。','A.Font类提供了创建字体对象的方法','B.字体风格（字型）使用了3个静态常量表示','C.表示字型的字体风格只能单独使用，不可以组合','D.字号表示字的大小，用点表示，一个点为1/72英寸','b',NULL),('1951000','第四单元','下列用来获取当前颜色的方法是______。','A.getColor（）','B.setColor（）	','C.getRed（）	','D.Color（）','b',NULL),('1951000','第四单元','下列各种绘制矩形的方法中，绘制实心矩形的方法是______。','A.fillRect（）','B.drawRect（）','C.clearReet（）','D. drawRoundReet（）','b',NULL),('1951000','第四单元','下列演示图像的描述中，错误的是______。','A.使用图像类Image定义图像对象','B.使用方法getlmage（）获取图像信息','C.使用方法drawlmage（）显示图像','D.不可使用显示图像的方法进行缩放','b',NULL),('1951000','第五单元','下列关于容器的描述中，错误的是______。','A.容器是由若干个组件和容器组成的','B.容器是对图形界面中界面元素的一种管理','C.容器是一种指定宽和高的矩形范围','D.容器都是可以独立的窗口','b',NULL),('1951000','第五单元','下列界面元素中，不是容器的是______。','A.List','B.Frame	','C.Dialog','D.Panel','b',NULL),('1951000','第五单元','下列关于实现图形用户界面的描述中，错误的是______。','A.放在容器中的组件首先要定义，接着要初始化','B.放在容器中的多个组件是要进行布局的，默认的布局策略是FlowLayout','C.容器中所有组件都是事件组件，都可产生事件对象','D.事件处理是由监听者定义的方法来实现的','b',NULL),('1951000','第五单元','下列关于组件类的描述中，错误的是______。','A.组件类中包含了文本组件类（TextComponent）和菜单组件类（MenuComponent）','B.标签（Label）和按钮（Button）是组件类（Component）的子类','C.面板（Panel）和窗口（Window）是容器类（Container）的子类','D.文本框（TextField）和文本区（TextArea）是文本组件类（TextComponent）的子类','b',NULL),('1951000','第五单元','在对下列语句的解释中，错误的是______。','A.but是某种事件对象，如按钮事件对象','B.this表示当前容器','C.ActionListener是动作事件的监听者','D.该语句的功能是将but对象注册为this对象的监听者','b',NULL),('1951000','第五单元','所有事件类的父类是______。','A.ActionEvent','B.AwtEvent','C.KeyEvent','D.MouseEvent','b',NULL),('1951000','第五单元','所有GUI标准组件类的父类是______。','A.Button','B.List','C.Component	','D.Container','b',NULL),('1951000','第五单元','在下列各种容器中，最简单的无边框的又不能移动和缩放的只能包含在另一种容器中的容器是______。','A.Window','B.Dialog	','C.Frame	','D.Panel','b',NULL),('1951000','第五单元','下列关于菜单和对话框的描述中，错误的是______。','A.Frame容器是可以容纳菜单组件的容器','B.菜单条中可包含若干个菜单，菜单中又可包含若干菜单项，菜单项中还可包含菜单子项','C.对话框与Frame一样都可作为程序的最外层容器','D.对话框内不含有菜单条，它是由Frame弹出','b',NULL);

/*Table structure for table `tablecode` */

DROP TABLE IF EXISTS `tablecode`;

CREATE TABLE `tablecode` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '1951000',
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '第二单元',
  `codetitle` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,
  `answer` text,
  `answerright` text,
  `key` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`key`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tablecode` */

insert  into `tablecode`(`id`,`unit`,`codetitle`,`answer`,`answerright`,`key`) values ('1951000','第一单元','编写一个Java Application程序，使该程序运行后输出字符串“Hello！How you.”。',NULL,'',1),('1951000','第一单元','编写一个JavaApplication程序，使该程序输出显示如下结果：\r\nvarl=10，var2=15.9\r\nok！\r\n',NULL,'1365465\r\n65-2-2-',2),('1951000','第二单元','已知：int a=3，b=5；\r\n求下列表达式的值：\r\n（1）（a+b）%b\r\n（2）b>>a\r\n（3）-b>>>a\r\n（4）a&.b\r\n（5）++a一b++\r\n',NULL,NULL,3),('1951000','第二单元','2-2已知：double x=1.5，y=2.8；\r\n求下列表达式的值：\r\n（1）x++>y--\r\n（2）x+4/5\r\n（3）2*×==y\r\n（4）y/6*6\r\n（5）y+=x-=1\r\n',NULL,NULL,4),('1951000','第二单元','2-3已知：boolean b1=true,b2=false；int a=6\r\n求下列表达式的值：\r\n（1）b1&b2\r\n（2）！b1&&b2||b2\r\n（3）b2&.b1|！b2\r\n（5）！（a>6）&a<6/（b2=true）\r\n（4）b1！=b2\r\n（5）！（a>6）&.a<6|（b2=true）\r\n',NULL,NULL,5),('1951000','第三单元','塒NG\r\n\Z\n',NULL,NULL,6),('1951000','第四单元','1. 编写.java源代码\r\n\r\nimport java.applet.* ;\r\n\r\npublic class HelloWorld extends Applet{\r\npublic void paint (Graphics g) {\r\ng.drawString(\"Hello World !\",20,20);\r\n\r\n}\r\n\r\n}\r\n\r\n2.将上边的代码保存在HelloWorld.java里边， 使用javac编译此文件\r\n',NULL,NULL,7),('1951000','第五单元','1: Swing用户界面组件与事件处理(请使用Eclipse，不要使用NetBeans，手写界面布局与事件监听器代码)\r\n需完成如上界面。请在以下代码的基础上进行修改\r\n\r\nimport javax.swing.JFrame;\r\n\r\npublic class HelloWorldSwing {\r\nprivate static void createAndShowGUI() {\r\n//Create and set up the window.\r\n\r\nJFrame frame = new JFrame(\"HelloWorldSwing\");\r\n\r\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\r\n//your code\r\n\r\n//Display the window.\r\n\r\nframe.pack();\r\n\r\nframe.setVisible(true);\r\n\r\n}\r\n\r\npublic static void main(String[] args) {\r\njavax.swing.SwingUtilities.invokeLater(new Runnable() {\r\npublic void run() {\r\ncreateAndShowGUI();\r\n\r\n}\r\n\r\n});\r\n\r\n}\r\n\r\n}\r\n',NULL,NULL,8);

/*Table structure for table `tablefill` */

DROP TABLE IF EXISTS `tablefill`;

CREATE TABLE `tablefill` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '1951000',
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '第五单元',
  `ftitle` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `fanswer` varchar(500) DEFAULT NULL,
  `fanswerright` varchar(500) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tablefill` */

insert  into `tablefill`(`id`,`unit`,`ftitle`,`fanswer`,`fanswerright`) values ('1951000','第一单元','Java语言是什么时间问世的？它与Internet有什么关系？',NULL,NULL),('1951000','第一单元','Java 语言有哪些特点？',NULL,NULL),('1951000','第一单元','Java语言取消了C++语言中的哪些内容？取消了这些内容后，给Java语言带来了什么好处？',NULL,NULL),('1951000','第一单元','Java语言的可移植性为什么比较高？',NULL,NULL),('1951000','第一单元',' Java语言程序分为哪两种？',NULL,NULL),('1951000','第一单元',' Java Application 程序在结构上有哪些特点？',NULL,NULL),('1951000','第一单元','Java程序在书写上应注意哪些事项？',NULL,NULL),('1951000','第二单元','Java的单词有哪些？Java语言使用的字符集与C++语言的相同吗？',NULL,NULL),('1951000','第二单元','标识符有何用途？标识符的规则是什么？',NULL,NULL),('1951000','第二单元','分隔符花括号通常用在什么地方？',NULL,NULL),('1951000','第二单元','文档注释符与多行注释符有何不同？',NULL,NULL),('1951000','第二单元','Java语言的基本数据类型包含哪几种？',NULL,NULL),('1951000','第二单元','字节型和字符型数据有何区别？',NULL,NULL),('1951000','第二单元','Java语言中基本数据类型的长度是随计算机的不同而不同吗？',NULL,NULL),('1951000','第二单元','长度为32位的基本数据类型有哪些？',NULL,NULL),('1951000','第二单元','Java语言中，复合数据类型有哪些？',NULL,NULL),('1951000','第二单元','Java语言中，数据类型转换有哪两种？当数据从低类型转换为高类型时需要用强制转换吗？',NULL,NULL),('1951000','第二单元','Java语言中，常量的种类有哪些？',NULL,NULL),('1951000','第二单元','整型常量有哪3种表示形式？浮点型变量有哪两种表示形式？',NULL,NULL),('1951000','第二单元','布尔型常量可以转换成其他数据类型吗？例如整型。',NULL,NULL),('1951000','第二单元','在Java语言的转义字符表示中，ASCI1码值对应的字符如何表示？Unicode字符集中对应的字符如何表示？',NULL,NULL),('1951000','第二单元','在Java 语言中，表示字符串常量时应注意哪些问题？',NULL,NULL),('1951000','第二单元','在Java语言中，表示字符常量时应该注意什么问题？',NULL,NULL),('1951000','第二单元','字符串变量的含义是什么？',NULL,NULL),('1951000','第二单元','Java语言中，变量的值除了有初值、默认值和改变值外，还有无意义值吗？2-19Java语言中，定义变量至少要指出哪些要素？',NULL,NULL),('1951000','第二单元','变量的作用域规则是怎样规定的？',NULL,NULL),('1951000','第二单元','Java语言中的变量有哪两种？',NULL,NULL),('1951000','第二单元','Java语言是否允许在嵌套的程序块中定义同名变量？',NULL,NULL),('1951000','第二单元','Java语言的运算符中按其操作数来划分，可分为哪些种类？举例说明。',NULL,NULL),('1951000','第二单元','Java语言的运算符按其功能通常分为哪些种类？',NULL,NULL),('1951000','第二单元','Java语言的运算符中按其优先级可划分几类？',NULL,NULL),('1951000','第二单元','Java语言的运算符中按其结合性可划分为哪些类？',NULL,NULL),('1951000','第二单元','Java 语言中，逻辑运算符有哪些？运算符&作为双目运算符，如何区分它是逻辑与还是按位与？',NULL,NULL),('1951000','第二单元','移位运算符中，两种右移运算符>和>有何不同？',NULL,NULL),('1951000','第二单元','对象运算符instance of如何使用？',NULL,NULL),('1951000','第二单元','内存分配运算符是什么？功能如何？',NULL,NULL),('1951000','第二单元','类的成员使用什么运算符表示？',NULL,NULL),('1951000','第二单元','有哪几种运算符组成的表达式的值是算术值？',NULL,NULL),('1951000','第二单元','有哪几种运算符组成的表达式的值是布尔值？',NULL,NULL),('1951000','第二单元','简洁逻辑运算符与非简洁逻辑运算符组成的表达式，在求值上有何不同？',NULL,NULL),('1951000','第二单元','什么是表达式语句？什么是空语句？',NULL,NULL),('1951000','第二单元','什么是块语句？可以把块语句视为一条语句吗？',NULL,NULL),('1951000','第二单元','Java语言中，选择语句有哪两种形式？',NULL,NULL),('1951000','第二单元','switch语句中，<语句序列>里一定要有break语句吗？',NULL,NULL),('1951000','第二单元','while循环语句与do-while循环语句有何不同？',NULL,NULL),('1951000','第二单元','for循环语句中，关键字for后面括号内的表达式是否可以使用多个用逗号分隔的表达式？？',NULL,NULL),('1951000','第二单元','break语句和continue语句各有哪两种形式？',NULL,NULL),('1951000','第二单元','import语句和package语句的功能分别是什么？',NULL,NULL),('1951000','第二单元','在Java语言中，如何定义一个数组？',NULL,NULL),('1951000','第二单元','Java中定义的数组都可以进行初始化吗？',NULL,NULL),('1951000','第二单元','J ava中数组在静态和动态赋值时都判越界吗？',NULL,NULL),('1951000','第二单元','数组元素为基本数据类型的数组，在创建时系统都给指定默认值吗？布尔型的默认值是什么？',NULL,NULL),('1951000','第二单元','Java中的数组实际上是一个隐含的“数组类”的对象，而数组名实际上是该对象的一个引用。这种说法对吗？',NULL,NULL),('1951000','第二单元','字符数组和字符串是两回事，而字符串实际上是String类和StringBuffer类的对象。这种说法对吗？',NULL,NULL),('1951000','第二单元','字符串有两种，分别是哪两种？它们之间有何不同？',NULL,NULL),('1951000','第三单元','什么是对象？什么是类？二者有何关系？',NULL,NULL),('1951000','第三单元','对象的三大要素是什么？',NULL,NULL),('1951000','第三单元','类的封装性、继承性和多态性各自的内容是什么？',NULL,NULL),('1951000','第三单元','类的定义格式是什么？Java语言和C++语言中定义类的格式是否相同？',NULL,NULL),('1951000','第三单元','定义类的修饰符有哪些？各自的特点是什么？',NULL,NULL),('1951000','第三单元','Java语言中，成员变量的定义格式如何？它有哪些修饰符？',NULL,NULL),('1951000','第三单元','Java语言中，方法的定义格式如何？方法的修饰符有哪些？',NULL,NULL),('1951000','第三单元','方法调用中应注意什么事项？',NULL,NULL),('1951000','第三单元','如何定义重载方法？如何选择重载方法？',NULL,NULL),('1951000','第三单元','构造方法的特点是什么？作用是什么？',NULL,NULL),('1951000','第三单元','析构方法的特点是什么？作用是什么？',NULL,NULL),('1951000','第三单元','什么是静态变量？什么是静态方法？各自有何特点？',NULL,NULL),('1951000','第三单元','静态初始化器有何功能？如何定义？',NULL,NULL),('1951000','第三单元','什么是抽象类？什么是抽象方法？各自有什么特点？',NULL,NULL),('1951000','第三单元','什么是最终类？什么是最终变量？什么是最终方法？',NULL,NULL),('1951000','第三单元','对象的定义格式如何？如何给对象初始化？如何给对象赋值？',NULL,NULL),('1951000','第四单元','Java Applet在结构上有何特点？',NULL,NULL),('1951000','第四单元','什么是HTML.文件？用来嵌套Applet的字节码文件的HTML文件有何特点？',NULL,NULL),('1951000','第四单元',' Applet程序是如何实现的？（即工作原理）',NULL,NULL),('1951000','第四单元','Applet程序与Applet类的关系如何？',NULL,NULL),('1951000','第四单元','Applet类有哪些主要方法？下述各种方法的主要功能是什么？',NULL,NULL),('1951000','第四单元',' Applet的典型结构如何？',NULL,NULL),('1951000','第四单元',' HTML中常用的标记有哪些？',NULL,NULL),('1951000','第四单元','如何使用HTML文件向Applet传递参数？',NULL,NULL),('1951000','第四单元','写出下述英文缩写的中文译文。GUI、AWT、html、URL',NULL,NULL),('1951000','第四单元','Java语言具有哪些多媒体功能？',NULL,NULL),('1951000','第四单元','如何定义图像对象？如何获取图像信息方法？如何显示图像？',NULL,NULL),('1951000','第四单元','如何实现动画？',NULL,NULL),('1951000','第四单元','如何进行声音播放？',NULL,NULL),('1951000','第五单元','AWT是什么含义？有何特点？',NULL,NULL),('1951000','第五单元','什么是容器？什么是组件？容器有什么特点？',NULL,NULL),('1951000','第五单元','常用的图形用户界面标准化组件有哪些？',NULL,NULL),('1951000','第五单元','简述实现图形用户界面的方法。',NULL,NULL),('1951000','第五单元','在界面元素的类结构中，MenuBar类的父类是什么？Container类的父类是什么？Frame类和Dialog类是哪个类的子类？',NULL,NULL),('1951000','第五单元','什么是事件？如何进行事件处理？',NULL,NULL),('1951000','第五单元','Java2中事件处理机制是什么？简述事件发生后的处理过程。',NULL,NULL),('1951000','第五单元','如何注册事件监听者',NULL,NULL),('1951000','第五单元','简单解释EventObject类和AwtEvent类的意义',NULL,NULL),('1951000','第五单元','动作事件（ActionEvent）的监听者接口是什么？主要方法是f什么？',NULL,NULL),('1951000','第五单元','Java语言中图形用户界面的3种组成成分各是什么？',NULL,NULL),('1951000','第五单元','组件和容器有何不同？',NULL,NULL),('1951000','第五单元','什么是布局设计？通常使用的布局管理器有哪些？各种不同布局管理器有什么特点？',NULL,NULL),('1951000','第五单元','常用的容器组件有哪些？它们各自的特点是什么？',NULL,NULL),('1951000','第五单元','解释下列菜单组件的含义。（1）MenuBar（2）Menu（3）MenuItem（4）CheckboxMenultem（5）PopupMenu',NULL,NULL),('1951000','第五单元','简述菜单组件设计步骤。',NULL,NULL),('1951000','第五单元','对话框容器的功能是什么？',NULL,NULL),('1951000','第五单元','对话框（Dialog）类的构造方法有哪些？',NULL,NULL);

/*Table structure for table `tablejudge` */

DROP TABLE IF EXISTS `tablejudge`;

CREATE TABLE `tablejudge` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '1951000',
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '第五单元',
  `jtitle` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  `choosea` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '正确',
  `chooseb` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT '错误',
  `answer` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT 'b',
  `answerright` varchar(200) DEFAULT NULL,
  `key` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`key`)
) ENGINE=InnoDB AUTO_INCREMENT=147 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tablejudge` */

insert  into `tablejudge`(`id`,`unit`,`jtitle`,`choosea`,`chooseb`,`answer`,`answerright`,`key`) values ('1951000','第一单元','Java语言是在C++语言之前问世的。','正确','错误','b',NULL,3),('1951000','第一单元','Java语言具有较好的安全性和可移植性及与平台无关等特性。','正确','错误','b',NULL,4),('1951000','第一单元',' Java语言中取消了联合概念，保留了结构概念。','正确','错误','b',NULL,5),('1951000','第一单元','Java语言中数据类型占内存字节数与平台无关。','正确','错误','b',NULL,6),('1951000','第一单元','Java语言中可用下标和指针两种方式表示数组元素。','正确','错误','b',NULL,7),('1951000','第一单元','Java语言的源程序不是编译型的，而是编译解释型的。','正确','错误','b',NULL,8),('1951000','第一单元','操作系统中进程和线程两个概念是没有区别的。','正确','错误','b',NULL,9),('1951000','第一单元',' Java语言既是面向对象的又是面向网络的高级语言。','正确','错误','b',NULL,10),('1951000','第一单元','Java程序分为两大类：一类是Application程序，另一类是Applet程库。前者又称Java应用程序，后者又称Java小应用程序。','正确','错误','b',NULL,11),('1951000','第一单元',' Java Application程序是由多个文件组成的，其中可以有也可以没有主文件。','正确','错误','b',NULL,12),('1951000','第一单元','组成JavaApplicntion 的着干类中，有且仅有一个主类，只有主类中合有生方法main（）。','正确','错误','b',NULL,13),('1951000','第一单元',' JavaApplication程序中，必有一个主方法main（），该方法有没有参数都可以。','正确','错误','b',NULL,14),('1951000','第一单元','Java程序中是不区分大小写字母的。','正确','错误','b',NULL,15),('1951000','第一单元','下述两个命令：javac和java是不同的，编译时用前者，运行时用后者。','正确','错误','b',NULL,16),('1951000','第一单元','Java程序编译后生成的是字节码文件，其后缀是.exe。','正确','错误','b',NULL,17),('1951000','第一单元','字节码文件机器是不能直接识别的，它要经过解释器，边解释边执行。','正确','错误','b',NULL,18),('1951000','第一单元','在Java程序中，使用import 语句引入类是在解释器中实现的。','正确','错误','b',NULL,19),('1951000','第一单元','在运行字节码文件时，使用java命令，一定要给出字节码文件的扩展名（class）。','正确','错误','b',NULL,20),('1951000','第一单元','如果一个Java程序中有多个类，编译后只生成一个字节码文件，其名字同主类名。','正确','错误','b',NULL,21),('1951000','第二单元','Java语言标识符中可以使用美元符。','正确','错误','b',NULL,22),('1951000','第二单元','Java语言标识符中大小写字母是没有区别的。','正确','错误','b',NULL,23),('1951000','第二单元','分号（;）、逗号（，）和冒号（：）都可作为Java语言中的分隔符。','正确','错误','b',NULL,24),('1951000','第二单元','文档注释符/**…*/是Java语言特有的注释符。','正确','错误','b',NULL,25),('1951000','第二单元',' Java 语言的基本数据类型有4种：整型、浮点型、字符型和布尔型。','正确','错误','b',NULL,26),('1951000','第二单元','Java 语言的复合数据类型有3种：数组、类和包。','正确','错误','b',NULL,27),('1951000','第二单元','Java语言中，字节型与字符型是一样的。','正确','错误','b',NULL,28),('1951000','第二单元','Java语言是一种强类型语言，数据类型转换有两种：隐含转换和强制转换。','正确','错误','b',NULL,29),('1951000','第二单元','数据由高类型转换到低类型时，采用强制转换，数据精度要受到损失。','正确','错误','b',NULL,30),('1951000','第二单元','布尔型常量可以自动转换为短整型常量。','正确','错误','b',NULL,31),('1951000','第二单元','Java语言使用的是Unicode字符集，每个字符在内存中占8位。','正确','错误','b',NULL,32),('1951000','第二单元','Java语言的字符串中不隐含结束符。','正确','错误','b',NULL,33),('1951000','第二单元','Java语言中定义符号常量使用final关键字','正确','错误','b',NULL,34),('1951000','第二单元','Java语言中不同数据类型的长度是固定的，不随机器硬件不同而改变。','正确','错误','b',NULL,35),('1951000','第二单元','Java语言中只有无符号的字符型。','正确','错误','b',NULL,36),('1951000','第二单元','字符型变量中只存放一个字符。','正确','错误','b',NULL,37),('1951000','第二单元','定义变量时必须进行初始化，否则变量具有无意义的值。','正确','错误','b',NULL,38),('1951000','第二单元','若定义变量时不进行初始化，则该变量一定具有默认值。','正确','错误','b',NULL,39),('1951000','第二单元','Java语言中，变量出现的位置只有一种，即为类体内定义的成员变量','正确','错误','b',NULL,40),('1951000','第二单元','Java语言规定在嵌套的程序块中不允许定义同名变量。','正确','错误','b',NULL,41),('1951000','第二单元','求余运算符%可用于整数和浮点数。','正确','错误','b',NULL,42),('1951000','第二单元','关系运算符组成的表达式是逻辑型表达式。','正确','错误','b',NULL,43),('1951000','第二单元','逻辑运算符&和&&是没有区别的，都具有逻辑与的功能。','正确','错误','b',NULL,44),('1951000','第二单元','运算符&是逻辑与运算符还是按位与运算符取决于操作数的类型。','正确','错误','b',NULL,45),('1951000','第二单元','运算符>>和>>都是右移位运算符，其区别在于对向右移出的位是舍弃还是保留。','正确','错误','b',NULL,46),('1951000','第二单元','赋值运算符组成的赋值表达式中，通常将右边表达式的类型转换为左边变量 的类型后再赋值。','正确','错误','b',NULL,47),('1951000','第二单元','三目运算符的3个操作数中，第一个操作数的类型必须是逻辑型的。','正确','错误','b',NULL,48),('1951000','第二单元','强制类型转换运算符的功能是将一个表达式的类型转换为所指定的类型。','正确','错误','b',NULL,49),('1951000','第二单元','对象运算符instance of是一个单目运算符，其表达式的值是类的对象。','正确','错误','b',NULL,50),('1951000','第二单元','内存分配运算符new可以为创建的数组分配内存空间，但不能为创建的变量分配空间。','正确','错误','b',NULL,51),('1951000','第二单元','运算符的优先级中，最低的是三目运算符。','正确','错误','b',NULL,52),('1951000','第二单元','运算符的结合性中，除了三目运算符是自右向左外，其余都是自左向右。','正确','错误','b',NULL,53),('1951000','第二单元','关系表达式和逻辑表达式的值都是布尔型的。','正确','错误','b',NULL,54),('1951000','第二单元','赋值表达式的值不能是逻辑型的。','正确','错误','b',NULL,55),('1951000','第二单元','条件表达式的类型总是“？”和“：”之间的操作数的类型。','正确','错误','b',NULL,56),('1951000','第二单元','块语句可以嵌套，外层块语句定义的变量在内层块语句中是可见的。','正确','错误','b',NULL,57),('1951000','第二单元','条件语句中的<条件>表达式可以是任何表达式。','正确','错误','b',NULL,58),('1951000','第三单元','类是一种类型，也是对象的模板。','正确','错误','b',NULL,59),('1951000','第三单元','Java 语言只支持单重继承，不支持多重继承。','正确','错误','b',NULL,60),('1951000','第三单元','类中说明的方法可以定义在类体外。','正确','错误','b',NULL,61),('1951000','第三单元','class不是定义类的唯一关键字。','正确','错误','b',NULL,62),('1951000','第三单元','某类的对象可以作为另个类的成员。','正确','错误','b',NULL,63),('1951000','第三单元','在类体内说明成员变量时不允许赋初值。','正确','错误','b',NULL,64),('1951000','第三单元','最终变量就是Java语言中的符号常量。','正确','错误','b',NULL,65),('1951000','第三单元','静态变量的引用只能使用对象','正确','错误','b',NULL,66),('1951000','第三单元','静态方法只能处理静态变量','正确','错误','b',NULL,67),('1951000','第三单元','抽象方法是一种只有说明而无具体实现的方法。','正确','错误','b',NULL,68),('1951000','第三单元','最终方法是不能被当前子类重新定义的方法。','正确','错误','b',NULL,69),('1951000','第三单元','Java 语言中，方法调用一律都是传址的引用调用。','正确','错误','b',NULL,70),('1951000','第三单元','非静态方法中不能引用静态变量。','正确','错误','b',NULL,71),('1951000','第三单元','静态初始化器是在构造方法被自动调用之前运行的。','正确','错误','b',NULL,72),('1951000','第三单元','抽象方法仅有方法头，而无方法体。','正确','错误','b',NULL,73),('1951000','第三单元','抽象方法一定出现在抽象类中。','正确','错误','b',NULL,74),('1951000','第三单元','最终类、最终方法和最终变量的修饰符都用final。','正确','错误','b',NULL,75),('1951000','第三单元','创建对象时系统将调用适当的构造方法给对象初始化。','正确','错误','b',NULL,76),('1951000','第三单元','使用运算符new创建对象时，赋给对象的值实际上是一个地址值。','正确','错误','b',NULL,77),('1951000','第三单元','使用构造方法只能给非静态成员变量赋初值。','正确','错误','b',NULL,78),('1951000','第三单元','创建对象时，该对象占有的内存空间除了非静态的成员变量外，还有非静态的','正确','错误','b',NULL,79),('1951000','第三单元','Java语言中，对象成员的表示只使用运算符“”。','正确','错误','b',NULL,80),('1951000','第三单元','Java语言中，对象赋值实际上同一个对象具有两个不同的名字，因为它们都有','正确','错误','b',NULL,81),('1951000','第三单元','对象可作方法参数，对象数组不能作方法参数。','正确','错误','b',NULL,82),('1951000','第三单元','Java语言中，所创建的子类都应有一个父类。','正确','错误','b',NULL,83),('1951000','第三单元','Java语言中，类的继承是可以传递的。','正确','错误','b',NULL,84),('1951000','第三单元','Java语言中，构造方法是可以继承的。','正确','错误','b',NULL,85),('1951000','第三单元','子类中构造方法应包含自身类的构造方法和直接父类的构造方法。','正确','错误','b',NULL,86),('1951000','第三单元','调用this或super 的构造方法的语句必须放在第一条语句。','正确','错误','b',NULL,87),('1951000','第三单元','子类对象可以直接赋值给父类对象；而父类对象不可以赋值给子类对象。','正确','错误','b',NULL,88),('1951000','第三单元','子类中所继承父类的成员都可以在子类中访问。','正确','错误','b',NULL,89),('1951000','第三单元','成员方法的重载和覆盖是一回事。','正确','错误','b',NULL,90),('1951000','第三单元','一个类可以实现多个接口。接口可以实现“多重继承”。','正确','错误','b',NULL,91),('1951000','第三单元','实现接口的类不能是抽象类。','正确','错误','b',NULL,92),('1951000','第四单元','Applet程序是通过浏览器中内置的Java解释器来解释执行的。','正确','错误','b',NULL,93),('1951000','第四单元','Applet程序是以.java为扩展名的Java语言源程序，该程序经过编译器后便成为可执行文件。','正确','错误','b',NULL,94),('1951000','第四单元','嵌入到HTML文件中的是Applet的源程序','正确','错误','b',NULL,95),('1951000','第四单元','运行Applet程序是使用AppletViewer命令运行嵌入了字节码文件的HTML文件，从而获得运行结果。','正确','错误','b',NULL,96),('1951000','第四单元','Applet程序中的主类必须是Applet类的子类。','正确','错误','b',NULL,97),('1951000','第四单元','Applet类是Java 语言类库中的一个重要的系统类，它被存放在javs.awl包中','正确','错误','b',NULL,98),('1951000','第四单元','init（）方法是用来完成初始化操作的，在Applet程序运行期间只执行一次。','正确','错误','b',NULL,99),('1951000','第四单元','starn（）方法被系统自动调用来启动主线程运行，通常在Applet程序被重新启动时，该方法被系统自动调用。','正确','错误','b',NULL,100),('1951000','第四单元','paint（）方法是在需要重画图形界面时被系统自动调用来显示输出结果的。','正确','错误','b',NULL,101),('1951000','第四单元','stop（）方法是用来暂停执行操作的，它与stat（）方法不同，只被调用一次。','正确','错误','b',NULL,102),('1951000','第四单元',' init（）、slar（）。stop（）和destroy（）4个方法构成Aplet程序的生命周期。','正确','错误','b',NULL,103),('1951000','第四单元','HTML语言中HEAD>和</HEAD>是用来表示HTML文件开始和结束的标记。','正确','错误','b',NULL,104),('1951000','第四单元','HTML中多数标记是成对出现的，也有不成对出现的标记。','正确','错误','b',NULL,105),('1951000','第四单元','HTML中是区分大小写字母的。','正确','错误','b',NULL,106),('1951000','第四单元','通过HTML文件中使用的PARAM标记可以向Applet程序传递参数的。4-16方法parseInt（）方法的功能是将int型数据转换为String型数据的。','正确','错误','b',NULL,107),('1951000','第四单元',' AWT提供了许多标准的GUI组件和布局管理器等类。','正确','错误','b',NULL,108),('1951000','第四单元','Java语言采用16位颜色标准。Java的调色板保证128色。','正确','错误','b',NULL,109),('1951000','第四单元','Graphics类提供了3种绘制文本的方法，其方法名都是drawString（）。','正确','错误','b',NULL,110),('1951000','第五单元','绘制椭圆的方法是drawOval（），使用该方法也可以绘制圆。','正确','错误','b',NULL,111),('1951000','第五单元','AWT是抽象窗口工具包的英文缩写。','正确','错误','b',NULL,112),('1951000','第五单元','容器中只能包含有组件，而不能再含有容器。','正确','错误','b',NULL,113),('1951000','第五单元','容器分可以独立的窗口和不可以独立的窗口两种。','正确','错误','b',NULL,114),('1951000','第五单元','单选按钮提供“多选一”的输入选择，下拉列表提供“多选多”的输入选择。','正确','错误','b',NULL,115),('1951000','第五单元','所有容器的默认布局都是FlowLayout。','正确','错误','b',NULL,116),('1951000','第五单元','所有的组件都是事件源。','正确','错误','b',NULL,117),('1951000','第五单元','Java2的事件处理方法是采用委托事件处理模型。','正确','错误','b',NULL,118),('1951000','第五单元','事件组件都应注册一个事件监听者。','正确','错误','b',NULL,119),('1951000','第五单元','事件监听者除了得知事件的发生外，还应调用相应方法处理事件。','正确','错误','b',NULL,120),('1951000','第五单元','所有事件类的父类是EventObject类。','正确','错误','b',NULL,121),('1951000','第五单元','图形用户界面是由用户自定义成分、控制组件和容器组成的。','正确','错误','b',NULL,122),('1951000','第五单元','所有GUI标准组件类的父类是Component类。','正确','错误','b',NULL,123),('1951000','第五单元','所有容器类的父类是Frame类。','正确','错误','b',NULL,124),('1951000','第五单元','标签和按钮都是事件源。','正确','错误','b',NULL,125),('1951000','第五单元','文本区和文本框都可以引发两种事件：文本改变事件和动作事件。','正确','错误','b',NULL,126),('1951000','第五单元','每个复选框有两种状态：“打开”和“关闭”状态。','正确','错误','b',NULL,127),('1951000','第五单元','单选按钮组（CheckboxGroup）是由若干个按钮组成的。在一组按钮中可选多个。','正确','错误','b',NULL,128),('1951000','第五单元','列表（List）是由多个选项组成的，只可在列表框的若干个选项选取一个。','正确','错误','b',NULL,129),('1951000','第五单元','下拉列表（Choice）是一种“多选多”的输入界面。','正确','错误','b',NULL,130),('1951000','第五单元',' 滚动条有两类：水平滚动条和垂直滚动条。','正确','错误','b',NULL,131),('1951000','第五单元','画布（Canvas）是一种可容纳多个组件的容器。','正确','错误','b',NULL,132),('1951000','第五单元','所有容器都采用顺序布局（FlowLayout）作为默认布局管理器。','正确','错误','b',NULL,133),('1951000','第五单元','边界布局（BorderLayout）将容器分为东、西、南、北共4个区域。','正确','错误','b',NULL,134),('1951000','第五单元','卡片布局（CardLayout）可使容器容纳多个组件，在同一时刻只显示若干个组件中的一个。','正确','错误','b',NULL,135),('1951000','第五单元','容器可容纳组件和容器，同一个容器中的组件可被同时显示或同时隐藏。','正确','错误','b',NULL,136),('1951000','第五单元','所有容器都是有边框的。','正确','错误','b',NULL,137),('1951000','第五单元','Panel容器是可以嵌套使用的。','正确','错误','b',NULL,138),('1951000','第五单元','Applet实际是一种特殊的Panel容器。Java Applet程序只负责它拥有的Applet容器内的无边框区域。','正确','错误','b',NULL,139),('1951000','第五单元','窗口（Window）容器是一种独立窗口，但它不能作为程序的最外层容器。','正确','错误','b',NULL,140),('1951000','第五单元','Frame容器是有边框的容器，它也是一种独立窗口，只能作为最外层容器。','正确','错误','b',NULL,141),('1951000','第五单元','Frame容器可以容纳菜单组件，它实现了MenuContainer接口。','正确','错误','b',NULL,142),('1951000','第五单元','MenuComponent类是菜单组件的父类。','正确','错误','b',NULL,143),('1951000','第五单元','菜单条（MenuBar）、菜单（Menu）、菜单项（Menultem）是3种不同的菜单组件。','正确','错误','b',NULL,144),('1951000','第五单元','对话框（Dialog）不是一种独立使用的容器。','正确','错误','b',NULL,145),('1951000','第五单元','文件对话框（FileDialog）是对话框（Dialog）的子类，它是一种打开文件和保留文件的对话框窗口。','正确','错误','b',NULL,146);

/*Table structure for table `tableknowledge` */

DROP TABLE IF EXISTS `tableknowledge`;

CREATE TABLE `tableknowledge` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '1951000',
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `knowtitle` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,
  `knowstate` int DEFAULT '0',
  `difficulty` float DEFAULT '4.5',
  `code` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,
  `tag` int DEFAULT '2',
  PRIMARY KEY (`id`,`unit`,`knowtitle`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tableknowledge` */

insert  into `tableknowledge`(`id`,`unit`,`knowtitle`,`content`,`knowstate`,`difficulty`,`code`,`tag`) values ('1951000','第一单元','java常见错误','0、 需要标识符\r\na) 不在函数内\r\n\r\n1、 非法表达式开始\r\nb) 可能:丢失括号 .\r\n\r\n2. no data found\r\na) 可能:setInt(1,100)中,没有100这个值\r\n\r\n3. 找不到符号\r\na) 可能:没导入包\r\n\r\n4. 指定了无效URL\r\na) 可能:数据库名或IP错误,即连接出错\r\n\r\n5. 类路径没有找到\r\na) 可能: ClassNotFoundException: oracle.jdbc.driver.OracleDriver\r\nb) 原因: 一般是指包名写错,或者没有import包,或者没有在类路径中找到jar文件\r\nc) 解决: 没有加载Oracle驱动jar,在.bash_profile中把ojdbc14.jar加进来\r\n\r\n6. 空指针异常\r\na) 可能: 数据源错误 比如数据库名或IP错误\r\n\r\n7. 不能执行查询\r\na) 可能: 数据库中表的问题,比如列名不存在\r\n\r\n8. invalid identity\r\na) 可能: 列名出错\r\n\r\n9. 若在数据库中创建了 两个sequence ,运行时出现异常可能是先后执行了多次select语句,导致与原有的序列号产生冲突\r\n\r\n10. 表名或列名不存在\r\na) 可能:表不存在或者没有插入数据到表中\r\n\r\n11. 不支持的类,类的版本错误\r\na) 可能:没有导入jdk5.0,或者编译器仍为1.4\r\n\r\n12. MappingNotFoundException\r\na) Maybe: In the Eclipse Not refersh , or not exist in the dirctory\r\n\r\n13. HibernateException: /hibernate.cfg.xml not found\r\na) Maybe1: hibernate.cfg.xml not in the root directory\r\nb) Maybe2: Could not parse configuration .\r\nc) resolve: database not connect or use another database\r\n\r\n14. ConstraintViolationException\r\na) Maybe: used a not true database\r\n\r\n15. 驱动没有找到 或者 JDBC Driver not found\r\n可能：连接数据库的驱动jar包不存在或者版本不一致，比如将旧的版本换成新的会造成该类错误\r\n\r\n\r\n16. 空指针异常 ， java.lang.NullPointerException\r\na) 可能1：数据库连接出错，比如在hibernate.cfg.xml中的数据错误会导致异常。\r\n\r\n17. 数据插入异常 ，GenericJDBCException: could not insert\r\na) 可能1：没有建立表或者表中没有任何数据\r\nb) 可能2：插入数据后没有执行提交语句：commit\r\n\r\n18. LazyInitializationException 或者延迟加载异常\r\na) 可能1：没有在查询语句中加fetch\r\n\r\n19. IdentifierGenerationException\r\na) 可能1：高位表没有初始化（比如hi_value中没有记录)\r\n\r\n20. could not initialize a collection: [hibernate.entity.Role.modules#32768] Syntax error: Encountered \"-\" at line 1, column 132.\r\na) 错误原因：<set name=\"modules\" table=\"module-role\" lazy=\"false\">红色字部分中“-”为非法字符，替换为module_role\r\n\r\n21. could not insert collection rows: [hibernate.entity.Module.roles#1]\r\n在Module.hbm.xml文件的如下配置中加入inverse=”true”\r\n<set name=\"roles\" table=\"module_role\" inverse=\"true\">\r\n\r\n',1,5.2,NULL,3),('1951000','第一单元','java编译与运行','Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。       \r\nJava程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）  2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ \"semi-interpreted\" language）。\r\n第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。\r\n第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。',0,8.8,'\r\n//MainApp.java\r\npublic class MainApp {\r\n	public static void main(String[] args) {\r\n		Animal animal = new Animal(\"Puppy\");\r\n		animal.printName();\r\n	}\r\n}\r\n//Animal.java\r\npublic class Animal {\r\n	public String name;\r\n	public Animal(String name) {\r\n		this.name = name;\r\n	}\r\n	public void printName() {\r\n		System.out.println(\"Animal [\"+name+\"]\");\r\n	}\r\n}\r\n',1),('1951000','第一单元','java虚拟机','1.1 OpenJDK\r\n自 1996 年 JDK 1.0 发布以来，Sun 公司在大版本上发行了 JDK 1.1、JDK 1.2、JDK 1.3、JDK 1.4、JDK 5，JDK 6 ，这些版本的 JDK 都可以统称为 SunJDK 。之后在 2006 年的 JavaOne 大会上，Sun 公司宣布将 Java 开源，在随后的一年多里，它陆续将 JDK 的各个部分在 GPL v2（GNU General Public License，version 2）协议下开源，并建立了 OpenJDK 组织来对这些代码进行独立的管理，这就是 OpenJDK 的来源，此时的 OpenJDK 拥有当时 sunJDK 7 的几乎全部代码。\r\n\r\n1.2 OracleJDK\r\n在 JDK 7 的开发期间，由于各种原因的影响 Sun 公司市值一路下跌，已无力推进 JDK 7 的开发，JDK 7 的发布一直被推迟。之后在 2009 年 Sun 公司被 Oracle 公司所收购，为解决 JDK 7 长期跳票的问题，Oracle 将 JDK 7 中大部分未能完成的项目推迟到 JDK 8 ，并于 2011 年发布了JDK 7，在这之后由 Oracle 公司正常发行的 JDK 版本就由 SunJDK 改称为 Oracle JDK。\r\n\r\n在 2017 年 JDK 9 发布后，Oracle 公司宣布从此以后 JDK 将会在每年的 3 月和 9 月各发布一个大版本，即半年发行一个大版本，目的是为了避免众多功能被捆绑到一个 JDK 版本上而引发的无法交付的风险。\r\n\r\n在 JDK 11 发布后，Oracle 同步调整了 JDK 的商业授权，宣布从 JDK 11 起将以前的商业特性全部开源给 OpenJDK ，这样 OpenJDK 11 和 OracleJDK 11 的代码和功能，在本质上就完全相同了。同时还宣布以后都会发行两个版本的 JDK ：\r\n\r\n一个是在 GPLv2 + CE 协议下由 Oracle 开源的 OpenJDK；\r\n一个是在 OTN 协议下正常发行的 OracleJDK。\r\n两者共享大部分源码，在功能上几乎一致。唯一的区别是 Oracle OpenJDK 可以在开发、测试或者生产环境中使用，但只有半年的更新支持；而 OracleJDK 对个人免费，但在生产环境中商用收费，可以有三年时间的更新支持。\r\n\r\n1.3 HotSpot VM\r\n它是 Sun/Oracle JDK 和 OpenJDK 中默认的虚拟机，也是目前使用最为广泛的虚拟机。最初由 Longview Technologies 公司设计发明，该公司在 1997 年被 Sun 公司收购，随后 Sun 公司在 2006 年开源 SunJDK 时也将 HotSpot 虚拟机一并进行了开源。之后 Oracle 收购 Sun 以后，建立了 HotRockit 项目，用于将其收购的另外一家公司（BEA）的 JRockit 虚拟机中的优秀特性集成到 HotSpot 中。HotSpot 在这个过程里面移除掉永久代，并吸收了 JRockit 的 Java Mission Control 监控工具等功能。到 JDK 8 发行时，采用的就是集两者之长的 HotSpot VM 。\r\n\r\n我们可以在自己的电脑上使用 java -version 来获得 JDK 的信息：\r\n二、Java 内存区域\r\n2.1 程序计数器\r\n程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要该计数器来完成。每条线程都拥有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。\r\n\r\n2.2 Java虚拟机栈\r\nJava 虚拟机栈（Java Virtual Machine Stack）也为线程私有，它描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。方法从调用到结束就对应着一个栈帧从入栈到出栈的过程。在《Java 虚拟机规范》中，对该内存区域规定了两类异常：\r\n\r\n如果线程请求的栈深度大于虚拟机所允许的栈深度，将抛出 StackOverflowError 异常；\r\n如果 Java 虚拟机栈的容量允许动态扩展，当栈扩展时如果无法申请到足够的内存会抛出 OutOfMemoryError 异常。\r\n2.3 本地方法栈\r\n本地方法栈（Native Method Stacks）与虚拟机栈类似，其区别在于：Java 虚拟机栈是为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\r\n\r\n2.4 Java堆\r\nJava 堆（Java Heap）是虚拟机所管理的最大一块的内存空间，它被所有线程所共享，用于存放对象实例。Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。Java 堆可以被实现成固定大小的，也可以是可扩展的，当前大多数主流的虚拟机都是按照可扩展来实现的，即可以通过最大值参数 -Xmx 和最小值参数 -Xms 进行设定。如果 Java 堆中没有足够的内存来完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。\r\n\r\n2.5 方法区\r\n方法区（Method Area）也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区也被称为 “非堆”，目的是与 Java 堆进行区分。《Java 虚拟机规范》规定，如果方法区无法满足新的内存分配需求时，将会抛出 OutOfMemoryError 异常。\r\n\r\n运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放常量池表（Constant Pool Table），常量池表中存放了编译期生成的各种符号字面量和符号引用。\r\n',1,5.6,'\r\nC:\\Users> java -version\r\njava version \"1.8.0_171\"   # 如果是openJDK, 则这里会显示：openjdk version\r\nJava(TM) SE Runtime Environment (build 1.8.0_171-b11)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode) # 使用的是HotSpot虚拟机，默认为服务端模式\r\n',1),('1951000','第一单元','java语言特点','1.简洁有效\r\n\r\nJava语言是一种相当简洁的“面向对象”的程序设计语言。Java语言克服了C++语言中的所有的难以理解和容易混淆的缺点，例如头文件、指针、结构、\r\n单元、运算符重载和虚拟基础类等。它更加严谨、简洁。\r\n\r\n2.可移植性\r\n\r\nJava语言最大的特点在于“一次编译，处处运行”，Java语言的执行基于java虚拟机的(JAVA Virtual Machine Jvm)运行，将源代码编译处字节码文件。\r\n在不同的操作系统上只需要与系统匹配的JVM就可以执行运行字节码文件，这样就降低了开发复杂度，提高了开发效率。\r\n\r\n3.面向对象\r\n\r\n面向对象是一种符合人类思维习惯的编程思想。现实生活中存在各种形态不同的事物，这些事物之间存在着各种各样的联系。在程序中使用对象来映\r\n射现实中的事物使用对象的关系来描述事物之间的联系，这种思想就是面向对象。而Java是一门面向对象的编程语言，并且有着更加良好的程序结构\r\n定义。\r\n\r\n4.垃圾回收\r\n\r\n垃圾指的是无用的内存回收，Java提供了垃圾回收机制( Garbage Collection,GC),利用GC机制 使得开发者在编写程序时只需考虑自身程序的合理性，\r\n而不用去关注GC问题，极大地简化了开发难度。\r\n\r\n5.引用传递\r\n\r\nJava避免使用复杂的指针，而使用更加简单的引用来代替指针。指针虽然是一种高效的内存处理模 式，但是其需要较强的逻辑分析能力。而Java在设\r\n计的时候充分地考虑到了这一点，所以开发者直接利 用引用就可以简化指针的处理。因此，引用也是在所有初学过程之中最为难以理解的部分\r\n\r\n6.适合分布式计算\r\n\r\nJava设计的初衷是为了更好地解决网络通信问题，所以Java语言非常适合于分布式计算程序的开发， 它不仅提供了简洁的 Socket开发支持、适合于公\r\n共网关接口( Common Gateway Interface,cGI)程序的 开发，还提供了对NIO、AO的支持，使得网络通信性能得到了强大的改善。\r\n\r\n7.健壮性\r\n\r\njava语言在进行编译时会进行严格的语法检查，可以是java的编译器是最“最严格”的编译器。在程序运行中可以通过合理的异常处理避免错误产生时的\r\n程序中断，从而保证java程序可以稳定运行。\r\n\r\n8. 多线程\r\n\r\n要理解线程，首先要理解并发的概念。并发是指在同一时间点，计算机可以同时执行多个任务。当前主流的操作系统，不管是Window系统，还是Linux系\r\n统，都是以多任务执行程序的。例如，我们可以在编写Java代码的同时听音乐、发送电子邮件等。在多任务系统中，每个独立执行的任务(应用程序)称为\r\n进程，多个任务可以并发执行。随着java语言不断的完成，java语言提供了JUC的多线程开发框架。降低开发者在使用多线程编程中的复杂程度。\r\n\r\n9. 安全性\r\n\r\nJava语言执行依赖于JVM解释字节码程序文件，而jvm拥有较高的安全性，同时随着java版本的不断更新，面对最新的安全隐患也可以及时更新处理。\r\n\r\n10.函数式编程\r\n\r\nJava语言中也对函数式编程有很好的支持(Lambda表达式)。利用函数式表达式编程可以更加简洁的实现程序代码的编写。',0,7.5,'\r\npublic class helloworld {\r\n    public static void main(String[] args){\r\n        System.out.println(\"hello world!\");\r\n        System.out.printf(\"hello world!!\\n\");\r\n        System.out.print(\"hello world!!!\");\r\n    }\r\n}\r\n',1),('1951000','第一单元','三层架构','三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了 “高内聚低耦合” 的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。\r\n\r\n表现层（JSP）：\r\n表现层也称为界面层，位于最外层（最上层），离用户最近。用于显示数据和接收用户输入的数据，为用户提供一种交互式操作的界面。\r\n\r\n业务层（逻辑层、service层）：\r\n业务层（Business Logic Layer）无疑是系统架构中体现核心价值的部分。它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为领域层。例如Martin Fowler在《Patterns of Enterprise Application Architecture》一书中，将整个架构分为三个主要的层：表示层、领域层和数据源层。作为领域驱动设计的先驱Eric Evans，对业务逻辑层作了更细致地划分，细分为应用层与领域层，通过分层进一步将领域逻辑与领域逻辑的解决方案分离。 　　业务层在体系架构中的位置很关键，它处于数据访问层与表示层中间，起到了数据交换中承上启下的作用。由于层是一种弱耦合结构，层与层之间的依赖是向下的，底层对于上层而言是“无知”的，改变上层的设计对于其调用的底层而言没有任何影响。如果在分层设计时，遵循了面向接口设计的思想，那么这种向下的依赖也应该是一种弱依赖关系。因而在不改变接口定义的前提下，理想的分层式架构，应该是一个支持可抽取、可替换的“抽屉”式架构。正因为如此，业务层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。对于数据访问层而言，它是调用者；对于表示层而言，它却是被调用者。依赖与被依赖的关系都纠结在业务层上，如何实现依赖关系的解耦，则是除了实现业务逻辑之外留给设计师的任务。\r\n\r\n持久层（DAO）：\r\n持久层，有时候也称为是数据访问层，其功能主要是负责数据库的访问，可以访问数据库系统、二进制文件、文本文档或是XML文档。采用DAO模式，建立实体类和数据库表映射（ORM映射）。简单的说法就是实现对数据表的select、insert、update以及delete的操作。如果要加入ORM的元素，那么就会包括对象和数据表之间的mapping，以及对象实体的持久化。\r\n\r\n三层与MVC的区别：\r\n\r\n \r\n\r\n很多人容易把三层模式与MVC模式混淆，三层与MVC的最不同的地方在于三层是没有Controller控制器的概念。虽然同样是架构级别的，三层与MVC相同的地方在于他们都有一个表现层，但是他们不同的地方在于其他的两个层。MVC没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了，在三层中也提到了Model概念，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层” 中典型的Model层是以实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。',0,4.6,'',1),('1951000','第一单元','垃圾收集','四、垃圾收集算法\r\n在 Java 虚拟机内存模型中，程序计数器、虚拟机栈、本地方法栈这 3 个区域都是线程私有的，会随着线程的结束而销毁，因此在这 3 个区域当中，无需过多考虑垃圾回收问题。垃圾回收问题主要发生在 Java 堆和方法区上。\r\n\r\n4.1 Java 堆回收\r\n在 Java 堆上，垃圾回收的主要内容是死亡对象（不可能再被任何途径使用的对象）。而判断对象是否死亡有以下两种方法：\r\n\r\n1. 引用计数法\r\n\r\n在对象中添加一个引用计数器，对象每次被引用时，该计数器加一；当引用失效时，计数器的值减一；只要计数器的值为零，则代表对应的对象不可能再被使用。该方法的缺点在于无法避免相互循环引用的问题：\r\n如上所示，此时两个对象已经不能再被访问，但其互相持有对对方的引用，如果采用引用计数法，则两个对象都无法被回收。\r\n\r\n2. 可达性分析\r\n\r\n上面的代码在大多数虚拟机中都能被正确的回收，因为大多数主流的虚拟机都是采用的可达性分析方法来判断对象是否死亡。可达性分析是通过一系列被称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为引用链（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，这代表 GC Roots 到该对象不可达， 此时证明此该对象不可能再被使用。\r\n在 Java 语言中，固定可作为 GC Roots 的对象包括以下几种：\r\n\r\n在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；\r\n在方法区中类静态属性引用的对象，譬如 Java 类中引用类型的静态变量；\r\n在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用；\r\n在本地方法栈中的 JNI（即 Native 方法）引用的对象；\r\nJava 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（如 NullPointException，OutOfMemoryError 等）及系统类加载器；\r\n所有被同步锁（synchronized 关键字）持有的对象；\r\n反应 Java 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调，本地代码缓存等。\r\n除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域的不同，还可能会有其他对象 “临时性” 地加入，共同构成完整的 GC Roots 集合。\r\n\r\n3. 对象引用\r\n\r\n可达性分析是基于引用链进行判断的，在 JDK 1.2 之后，Java 将引用关系分为以下四类：\r\n\r\n强引用 (Strongly Reference) ：最传统的引用，如 Object obj = new Object() 。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。\r\n软引用 (Soft Reference) ：用于描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会被列入回收范围内进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。\r\n弱引用 (Weak Reference) ：用于描述那些非必须的对象，强度比软引用弱。被弱引用关联对象只能生存到下一次垃圾收集发生时，无论当前内存是否足够，弱引用对象都会被回收。\r\n虚引用 (Phantom Reference) ：最弱的引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。\r\n4. 对象真正死亡\r\n\r\n要真正宣告一个对象死亡，需要经过至少两次标记过程：\r\n\r\n如果对象在进行可达性分析后发现 GC Roots 不可达，将会进行第一次标记；\r\n随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalized() 方法。如果对象没有覆盖 finalized() 方法，或者 finalized() 已经被虚拟机调用过，这两种情况都会视为没有必要执行。如果判定结果是有必要执行，此时对象会被放入名为 F-Queue 的队列，等待 Finalizer 线程执行其 finalized() 方法。在这个过程中，收集器会进行第二次小规模的标记，如果对象在 finalized() 方法中重新将自己与引用链上的任何一个对象进行了关联，如将自己（this 关键字）赋值给某个类变量或者对象的成员变量，此时它就实现了自我拯救，则第二次标记会将其移除 “即将回收” 的集合，否则该对象就将被真正回收，走向死亡。\r\n4.2 方法区回收\r\n在 Java 堆上进行对象回收的性价比通常比较高，因为大多数对象都是朝生夕灭的。而方法区由于回收条件比较苛刻，对应的回收性价比通常比较低，主要回收两部分内容：废弃的常量和不再使用的类型。\r\n\r\n4.3 垃圾收集算法\r\n1. 分代收集理论\r\n\r\n当前大多数虚拟机都遵循 “分代收集” 的理论进行设计，它建立在强弱两个分代假说下：\r\n\r\n弱分代假说 (Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。\r\n强分代假说 (Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。\r\n跨带引用假说 (Intergenerational Reference Hypothesis)：基于上面两条假说还可以得出的一条隐含推论：存在相互引用关系的两个对象，应该倾向于同时生存或者同时消亡。\r\n强弱分代假说奠定了垃圾收集器的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄就是对象经历垃圾收集的次数）分配到不同的区域中进行存储。之后如果一个区域中的对象都是朝生夕灭的，那么收集器只需要关注少量对象的存活而不是去标记那些大量将要被回收的对象，此时就能以较小的代价获取较大的空间。最后再将难以消亡的对象集中到一块，根据强分代假说，它们是很难消亡的，因此虚拟机可以使用较低的频率进行回收，这就兼顾了时间和内存空间的开销。\r\n\r\n2. 回收类型\r\n\r\n根据分代收集理论，收集范围可以分为以下几种类型：\r\n\r\n部分收集 (Partial GC)：具体分为：\r\n新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；\r\n老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\r\n混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。\r\n整堆收集 (Full GC)：收集整个 Java 堆和方法区。\r\n3. 标记-清除算法\r\n\r\n它是最基础的垃圾收集算法，收集过程分为两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；也可以反过来，标记存活对象，统一回收所有未被标记的对象。\r\n',0,4.8,'\r\nobjA.instance = objB\r\nobjB.instance = objA    \r\nobjA = null;\r\nobjB = null;\r\nSystem.gc();',2),('1951000','第三单元','java中break和continue的用法','\r\nbreak的用法：\r\n1.break用于switch语句中，终止switch语句\r\n2.break用于循环时，跳出循环\r\n3.break用于其他位置，毫无意义\r\n\r\ncontinue的用法：\r\n1.continue用在循环中，跳出本次循环，继续执行下一次循环\r\n2.continue用在其他地方毫无意义',0,4.5,'\r\nint sum=0;\r\n        for(int i=1;i<=100;i++){\r\n            if(i>10)\r\n                break;\r\n            sum+=i;\r\n        }\r\n\r\nint i;\r\n        continue;\r\n        for(i=1;i<10;i++){\r\n            if(i==5)\r\n                continue;\r\n            System.out.print(i+\"  \");\r\n        }\r\n',2),('1951000','第三单元','java控制流','\r\n一：\r\n\r\n块作用域\r\n\r\n块(即复合语句)：是指由一对花括号括起来的若干条简单的java语句。块决定了变量的作用域，一个块可以嵌套在另一个块中，如下：\r\n\r\n1 public classprint_In {2 public static voidmain(String[] args){3 int a=2;4 {5 int a=3;6 int b=3;7 }8 }9 }\r\n\r\n需要注意：在一个块里，定义个变量，不能再嵌套的块里在定义相同的变量，如果定义会报错。\r\n\r\n\r\n二：if语句\r\n\r\n语法形式和js是一样：if(){}else if (){} ......else{}\r\n\r\njava里的if语句不同于python里的if语句，python里可以直接用数组、字符串、字典等来充当条件，但是在java里只能使用表达式直接可以判断布尔值，才可以做判断，否则会报错。\r\n\r\n1 public classprint_In {2 public static voidmain(String[] args){3 int a=2;4 int v=4;5 if (a<4){6 System.out.println(\"OK\");7 }else{8 System.out.println(\"bad\");9 }10 }11 }\r\n\r\n错误的写法：\r\n\r\n1 public classprint_In {2 public static voidmain(String[] args){3 int a=2;4 int v=4;5 if(a){6 System.out.println(\"OK\");7 }else{8 System.out.println(\"bad\");9 }10 }11 }\r\n\r\n\r\nfor循环：\r\n\r\n语法：for (){} 通过计数器或者变量的值修改。来结束for循环，()表达式里包含三部分，初始化一个变量并赋值，变量的布尔比较，变量的自增。目的是循环的跳出。变量的作用域，作用域循环体。\r\n\r\n如下：\r\n\r\n1 public classprint_In {2 public static voidmain(String[] args) {3 inti;4 for(i=2;i<4;i++){5 System.out.println(i);6 }7 System.out.printf(\"i value is %s \",i);8 }9 }\r\n\r\n如果main方法想使用for循环之后的变量值，需要在for循环外定义这个变量。才可以被外部调用！\r\n\r\nwhile 语句：\r\n\r\n形式：while(condition){statement} 这种形式，当condition 成立的时候，才运行块代码，如果不成立将不会运行。\r\n\r\n1 public classprint_In{2 public static voidmain(String[] args){3 int i=3;4 while (i<6){5 System.out.println(i);6 i+=1;7 }8 }9 }\r\n\r\nwhile 循环另一个形式： do  {statement}while(condition)会运行一次块代码，在做判断。\r\n\r\n1 public classprint_In{2 public static voidmain(String[] args){3 int i=3;4 do{5\r\n\r\n6 System.out.println(i);7\r\n\r\n8 }while (i<3);9 }10 }\r\n',0,4.5,NULL,2),('1951000','第三单元','java数学函数','见代码',0,4.5,'Math.abs(12.3);                 //12.3 返回这个数的绝对值  \r\nMath.abs(-12.3);                //12.3  \r\n  \r\nMath.copySign(1.23, -12.3);     //-1.23,返回第一个参数的量值和第二个参数的符号  \r\nMath.copySign(-12.3, 1.23);     //12.3  \r\n  \r\nMath.signum(x);                 //如果x大于0则返回1.0，小于0则返回-1.0，等于0则返回0  \r\nMath.signum(12.3);              //1.0  \r\nMath.signum(-12.3);             //-1.0  \r\nMath.signum(0);                 //0.0  \r\n  \r\n  \r\n//指数  \r\nMath.exp(x);                    //e的x次幂  \r\nMath.expm1(x);                  //e的x次幂 - 1  \r\n  \r\nMath.scalb(x, y);               //x*(2的y次幂）  \r\nMath.scalb(12.3, 3);            //12.3*2³  \r\n  \r\n//取整  \r\nMath.ceil(12.3);                //返回最近的且大于这个数的整数13.0  \r\nMath.ceil(-12.3);               //-12.0  \r\n  \r\nMath.floor(12.3);               //返回最近的且小于这个数的整数12.0  \r\nMath.floor(-12.3);              //-13.0  \r\n  \r\n//x和y平方和的二次方根  \r\nMath.hypot(x, y);               //√（x²+y²）  \r\n  \r\n//返回概述的二次方根  \r\nMath.sqrt(x);                   //√(x) x的二次方根  \r\nMath.sqrt(9);                   //3.0  \r\nMath.sqrt(16);                  //4.0  \r\n  \r\n//返回该数的立方根  \r\nMath.cbrt(27.0);                //3   \r\nMath.cbrt(-125.0);              //-5  \r\n  \r\n//对数函数  \r\nMath.log(e);                    //1 以e为底的对数  \r\nMath.log10(100);                //10 以10为底的对数  \r\nMath.log1p(x);                  //Ln（x+ 1）  \r\n  \r\n//返回较大值和较小值  \r\nMath.max(x, y);                 //返回x、y中较大的那个数  \r\nMath.min(x, y);                 //返回x、y中较小的那个数  \r\n  \r\n//返回 x的y次幂  \r\nMath.pow(x, y);                   \r\nMath.pow(2, 3);                 //即2³ 即返回：8  \r\n  \r\n//随机返回[0,1)之间的无符号double值  \r\nMath.random();                    \r\n  \r\n//返回最接近这个数的整数,如果刚好居中，则取偶数  \r\nMath.rint(12.3);                //12.0   \r\nMath.rint(-12.3);               //-12.0  \r\nMath.rint(78.9);                //79.0  \r\nMath.rint(-78.9);               //-79.0  \r\nMath.rint(34.5);                //34.0  \r\nMath.rint(35.5);                //36.0  \r\n  \r\nMath.round(12.3);               //与rint相似，返回值为long  \r\n  \r\n//三角函数  \r\nMath.sin(α);                    //sin（α）的值  \r\nMath.cos(α);                    //cos（α）的值  \r\nMath.tan(α);                    //tan（α）的值  \r\n  \r\n//求角  \r\nMath.asin(x/z);                 //返回角度值[-π/2，π/2]  arc sin（x/z）  \r\nMath.acos(y/z);                 //返回角度值[0~π]   arc cos（y/z）  \r\nMath.atan(y/x);                 //返回角度值[-π/2，π/2]  \r\nMath.atan2(y-y0, x-x0);         //同上，返回经过点（x，y）与原点的的直线和经过点（x0，y0）与原点的直线之间所成的夹角  \r\n  \r\nMath.sinh(x);                   //双曲正弦函数sinh(x)=(exp(x) - exp(-x)) / 2.0;  \r\nMath.cosh(x);                   //双曲余弦函数cosh(x)=(exp(x) + exp(-x)) / 2.0;  \r\nMath.tanh(x);                   //tanh(x) = sinh(x) / cosh(x);  \r\n  \r\n//角度弧度互换  \r\nMath.toDegrees(angrad);         //角度转换成弧度，返回：angrad * 180d / PI  \r\n  \r\nMath.toRadians(angdeg);         //弧度转换成角度，返回：angdeg / 180d * PI  ',2),('1951000','第三单元','Java运算符和表达式','常用运算符\r\n\r\n运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。Java也提供了一套丰富的运算符来操纵变量，们可以把运算符分成以下几组：\r\n\r\n算术运算符、关系运算符、位运算符、逻辑运算符、赋值运算符 和 其他运算符\r\n\r\n \r\n\r\n算数运算符\r\n\r\n算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。表格中的实例假设整数变量A的值为10，变量B的值为20：\r\n\r\n操作符	描述	例子\r\n+	加法 - 相加运算符两侧的值	A + B 等于 30\r\n-	减法 - 左操作数减去右操作数	A – B 等于 -10\r\n*	乘法 - 相乘操作符两侧的值	A * B等于200\r\n/	除法 - 左操作数除以右操作数	B / A等于2\r\n％	取余 - 左操作数除以右操作数的余数	B%A等于0\r\n++	自增: 操作数的值增加1	B++ 或 ++B 等于 21\r\n--	自减: 操作数的值减少1	B-- 或 --B 等于 19\r\n自增自减运算符\r\n\r\n自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。\r\n\r\n前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。\r\n',0,4.5,'\r\npublic class Test {\r\n    public static void main(String[] args){\r\n        int a = 5;//定义一个变量；\r\n        int b = 5;\r\n        // 拆分运算过程为: a=a+1=6; x=2*a=12\r\n        int x = 2*++a;\r\n        // 拆分运算过程为: y=2*b=2*5=10; b=b+1=6\r\n        int y = 2*b++;\r\n        System.out.println(\"a=\"+a+\",x=\"+x); // a=6, x=12\r\n        System.out.println(\"b=\"+b+\",y=\"+y); // b=6, y=10\r\n    }\r\n}\r\n',2),('1951000','第三单元','操作数','算数运算符\r\n\r\n算术运算符以数值(字面量或变量)作为其操作数，并返回一个单个数值。标准算术运算符是加法(+)，减法(-)，乘法(*)和除法(/)。\r\n\r\n算数运算符是用来做算数运算的，如 + 这个符号，就是用来做加法操作。\r\n\r\n加法 (+)： 加法运算符的作用是数值求和，或者字符串拼接。\r\n\r\n语法：\r\n\r\n运算符: x + y\r\n\r\n减法 (\r\n\r\n位运算符的概念和使用2021-02-23 18:31:40\r\n\r\n逻辑运算符\r\n\r\n&&：逻辑与，全真才为真。 若第一个操作数为假，肯定为假，就不判断第二个了。 ||：逻辑或，有真即为真。 若第一个操作数为真 ，肯定为假，就不判断第二个了。 ！：逻辑非。 用来反转操作数的逻辑状态。例true取非后为false。\r\n\r\n位运算符：\r\n\r\n操作数在计算机中以补码形式存在，int为4字节 (32)\r\n\r\n作者： 负雪明烛id： fuxuemingzhu公众号：每日算法题本文关键词：LeetCode，力扣，算法，算法题，交替合并字符串，Merge Strings Alternately，刷题群\r\n\r\n目录\r\n\r\n题目描述解题思路暴力动态规划\r\n\r\n欢迎加入组织日期\r\n\r\n题目地址：https://leetcode-cn.com/problems/merge-strings-alternately/\r\n\r\n题目描述\r\n\r\nJava运算符2021-02-20 20:33:26\r\n\r\n给大家拜一个晚年，牛年大吉，身体健康，年前年后自己要处理的事太多，都没空学习，一直拖到今天才开始，要加倍努力了，补上落下的知识。我接着以前的知识，开始学习运算符，在Java中运算符是告知编译器在计算器执行特定数学或者逻辑操作的符号，Java给我们提供了4种基本运算符类型:算数运算符，位\r\n\r\n8086CPU中的寻址方式一2021-02-20 15:32:26\r\n\r\n寻址方式\r\n\r\n定义\r\n\r\n寻址方式：求操作数所在地或者所在存储器地址单元的方式。\r\n\r\n指令中的操作数，大多数都在存储器单元当中，也可以在寄存器里面，也可以是在指令中立即给出的常数。我们都把求得她们的方式归属于寻址方式。\r\n\r\n类型\r\n\r\n寻址方式按求得的操作数的目的不同，可以分为两类：\r\n\r\n数据用\r\n\r\n程\r\n\r\n在汇编语言中，1行表示对CPU的一个指令。汇编语言指令的语法结构是操作码+操作数￼(也存在只有操作码没有操作数的指令)①。\r\n\r\n操作码表示的是指令动作，操作数表示的是指令对象。操作码和操作数罗列在一起的语法，就是一个英文的指令文本。操作码是动词，操作数相当于宾语。例如，用汇编语言来\r\n\r\nJava并发_6 CAS2021-02-19 19:31:47\r\n\r\nCAS\r\n\r\nCAS什么是CAS算法本质\r\n\r\n应用场景乐观锁并发容器源码：分析Java如何利用CAS实现原子操作\r\n\r\nUnsafe缺点\r\n\r\nCAS的深度拓展CAS的ABA问题CAS的底层原理关于volatilelock前缀的作用volatile伪共享\r\n\r\nCAS\r\n\r\n什么是CAS\r\n\r\nCompareAndSwap，是一种思想和算法，由CPU指令保证原子性。\r\n\r\n我认为V\r\n\r\nJS-01 JS基础2021-02-18 03:33:01\r\n\r\n类型转换\r\n\r\n转化为数字\r\n\r\nnull -> 0\r\n\r\nundefined -> NaN\r\n\r\nstring类型 -> 去掉头尾空格读数字; 剩余空字符串(0), 其他(NaN)\r\n\r\n转化为boolean\r\n\r\nfalse: 0, 空字符串, null, undefined, NaN\r\n\r\nTrue; 其他(包括\"0\", -1 ...)\r\n\r\n基础运算\r\n\r\n\"3\"*\"5\" = 15\r\n\r\n值的比较\r\n\r\n字符串比较: 字典\r\n\r\n中缀、后缀、前缀表达式2021-02-17 22:01:46\r\n\r\n中缀表达式\r\n\r\n中缀转后缀\r\n\r\n中缀转后缀的手算方法：\r\n\r\n(1)确定中缀表达式中各个运算符的运算顺序\r\n\r\n(2)选择下一个运算符，按照【左操作数 右操作数 运算符】的方式组合成一个新的操作数\r\n\r\n(3)如果还有运算符没被处理，就继续(2)\r\n\r\nA+B*(C-D)-E/F\r\n\r\n(1)先算C-D，转成后缀就是CD-，把它看作一个新的操作数FirstC\r\n\r\nCp2_3_2.py2021-02-05 20:58:34\r\n\r\n#!/usr/bin/env python\r\n\r\n# -*- coding: utf-8 -*-\r\n\r\n# @File : Cp2_3_2.py\r\n\r\n# @Author: WRH\r\n\r\n# @Date : 2021/2/2\r\n\r\n# @Edition:Python3.8.6\r\n\r\n# 运算符\r\n\r\n# 1.算术运算符\r\n\r\n\'\'\'\r\n\r\n# 以下各模块运算符优先级递增，模块内运算符优先级相同\r\n\r\n模块一：\r\n\r\n+加法：两个对象相加，或者一元加x + y\r\n\r\n-减\r\n\r\n硬编码2021-02-03 13:04:29\r\n\r\n前缀指令\r\n\r\n一、LOCK和REPEAT指令\r\n\r\nLock F0h\r\n\r\nrepne/repnz F2h\r\n\r\nrep/repz F3h\r\n\r\n二、段前缀指令\r\n\r\nCS:2Eh\r\n\r\nSS:36h\r\n\r\nDS:3Eh\r\n\r\nES:26h\r\n\r\nFS:64h\r\n\r\nGS:65h\r\n',0,4.5,NULL,2),('1951000','第三单元','简单输入输出','见代码',0,4.5,'\r\npublic class Welcome {\r\n	\r\n//每一个java程序必须至少有一个类，每个类有一个名字，一般来说这个类名首字母是要求大写的\r\n//	如果定义的是public类，这里的名字必须和文件名保持一致，不然会报错\r\n	\r\n	public static void main(String[] args) {\r\n		\r\n//		一个个解释这里对应的意思，public为公有类，即大家都可以访问；static为静态方法，\r\n//		被static所修饰的变量或者方法会储存在数据共享区；void表示该函数没有返回值。\r\n//		这一行还定义了main方法，说明我们这个程序是用main方法编译的，一个程序可能有\r\n//		多种方法，但是必须包含一个main方法，因为程序从他这里开始编译。\r\n		\r\n		System.out.println(\"Welcome to Java programming!\");\r\n		\r\n//		这是一句标准的输出语句。\r\n		\r\n		System.out.println(\"Have you ever\" +\r\n				\"learned C++?\");\r\n		\r\n//		如果一句话过长，想要分解成两行，切忌直接转行，需要把转行前的句子用双引号\r\n//		括起来，转行后的句子用双引号括起来，两者用加号连接。这里的加号的作用是连接\r\n//		两个字符串，它本身还有做加法运算的功能。\r\n		\r\n		System.out.print(\"Enter a number in the console.\");\r\n		System.out.print(\"1\");\r\n		\r\n		System.out.println(\"Enter a number in the console.\");\r\n		System.out.println(\"1\");\r\n		\r\n//		这是输出的另外一种写法，print和println的区别在于，println会自动转到下一行输出，而print不会。\r\n//		可自行观察这两个的输出发现规律。\r\n	}\r\n}\r\n',2),('1951000','第二单元','java代码注释规范','代码注释是架起程序设计者与程序阅读者之间的通信桥梁，最大限度的提高团队开发合作效率。也是程序代码可维护性的重要环节之一。所以我们不是为写注释而写注释。下面说一下我们在诉求网二期开发中使用的代码注释规范，供大家参考下。\r\n\r\n原则：\r\n1、注释形式统一\r\n\r\n在整个应用程序中，使用具有一致的标点和结构的样式来构造注释。如果在其它项目中发现它们的注释规范与这份文档不同，按照这份规范写代码，不要试图在既成的规范系统中引入新的规范。\r\n\r\n2、注释内容准确简洁\r\n\r\n内容要简单、明了、含义准确，防止注释的多义性，错误的注释不但无益反而有害。\r\n',0,4.5,'\r\n/**\r\n\r\n* 类的描述\r\n\r\n* @author Administrator\r\n\r\n* @Time 2012-11-2014:49:01\r\n\r\n*\r\n\r\n*/\r\n\r\npublic classTest extends Button {\r\n\r\n  ……\r\n\r\n}',2),('1951000','第二单元','java变量','1、变量的概念：\r\n\r\n内存中的一个存储区域\r\n该区域有自己的名称（变量名）和类型（数据类型）\r\nJava中每个变量必须先声明，后使用\r\n该区域的数据可以在同一类型范围内不断变化\r\n使用变量注意：\r\n变量的作用域：一对{ }之间有效 \r\n初始化值\r\n定义变量的格式： 数据类型    变量名  =  初始化值\r\n变量是通过使用变量名来访问这块区域的\r\n\r\n\r\n2、变量的分类\r\n\r\n对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间\r\n\r\n1）整数类型：byte、short、int、long\r\n\r\n\r\nJava各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。\r\njava的整型常量默认为int型，声明long型常量须后加‘l’或‘L’\r\n\r\n2）浮点类型：float、double\r\n\r\n\r\n与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体OS的影响。\r\nava的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。\r\n浮点型常量有两种表示形式：十进制数形式：如：5.12       512.0f        .512  (必须有小数点）、科学计数法形式:如：5.12e2      512E2    100E-2\r\n\r\n3）字符类型：char\r\n\r\n\r\nchar 型数据用来表示通常意义上“字符”(2字节)\r\n字符型常量的三种表现形式：字符常量是用单引号(‘’)括起来的单个字符，涵盖世界上所有书面语的字符。例如：charc1 = \'a\';   char c2 = \'中\';char c3 =  \'9\';  Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：charc3 = ‘\\n’;  // \'\\n\'表示换行符直接使用 Unicode值来表示字符型常量：‘\\uXXXX’。其中，XXXX代表一个十六进制整数。如：\\u000a表示 \\n。char类型是可以进行运算的。因为它都对应有Unicode码。\r\n4）布尔类型：boolean\r\n\r\n\r\nboolean类型适于逻辑运算，一般用于程序流程控制：\r\n        if 条件控制语句；                 \r\n        while 循环控制语句；\r\n        do-while 循环控制语句；     \r\n        for 循环控制语句；\r\nboolean类型数据只允许取值true和false，无null。\r\n        不可以0或非 0 的整数替代false和true，这点和C语言不同\r\n',0,4.5,'\r\nString s0 = “hello”;\r\nString s1 = “hello”;\r\nString s2 = “he” + “llo”;\r\nSystem.out.println(s0==s1);\r\nSystem.out.println(s0==s2);',2),('1951000','第二单元','java基本语法','关键字\r\n关键字的定义和特点\r\n定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）\r\n特点：关键字中所有字母都为小写\r\n保留字\r\nJava保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标记符时要避免使用这些保留字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const\r\n标识符\r\n标识符：\r\nJava 对各种变量、方法和类等要素命名时使用的字符序列称为标识符\r\n凡是自己可以起名字的地方都叫标识符。\r\n定义合法标识符规则：\r\n由26个英文字母大小写，0-9 ，_或 $ 组成\r\n数字不可以开头。\r\n不可以使用关键字和保留字，但能包含关键字和保留字。\r\nJava中严格区分大小写，长度无限制。\r\n标识符不能包含空格。\r\n注意：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。\r\nJava中的名称命名规范：\r\n包名：多单词组成时所有字母都小写：xxxyyyzzz\r\n类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz\r\n变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz\r\n常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\r\n变量\r\n变量的概念：\r\n内存中的一个存储区域\r\n该区域有自己的名称（变量名）和类型（数据类型）\r\nJava中每个变量必须先声明，后使用\r\n该区域的数据可以在同一类型范围内不断变化\r\n使用变量注意：\r\n变量的作用域：一对{ }之间有效\r\n初始化值\r\n定义变量的格式：数据类型 变量名 = 初始化值\r\n变量是通过使用变量名来访问这块区域的\r\n',0,4.5,'\r\nString s0 = “hello”;\r\nString s1 = “hello”;\r\nString s2 = “he” + “ll”+”o”;\r\nSystem.out.println(s0 ==s1);\r\nSystem.out.println(s0 ==s2);',2),('1951000','第二单元','复合数据类型','1、Java字符串\r\n在 Java 中字符串被作为 String 类型的对象处理。 String 类位于 java.lang 包中，默认情况下该包自动导入。\r\n\r\nString对象创建后不会被修改，当我们修改某个字符串对象实际上是将原引用指向了新创建的内存空间。并且相同的字符串常量Java不会分配两个内存空间，而是将两个引用指向相同的空间。\r\n2、Java中的包装类\r\nJava中的基本数据类型如int、double等都不具有对象的特性，为了像其他对象一样拥有自己的方法，Java为每个基本数据类型提供了包装类，像对象那样来操作基本数据类型。包装类的基本方法用于实现类型之间的相互转换。\r\n\r\nJava包装类可以自动装箱/拆箱，即通过=运算符自动完成基本类型和包装类之间的类型转换。\r\n3、Java容器\r\n在各种基本数据类型的基础上，Java使用集合类当作容器来储存具有相同属性的对象。通过集合类组织数据可以实现对特定数据的快速插入、删除与查询操作。而且与数组相比，集合的长度灵活可变，而且查找方式也不只有下标一种。Java中常见的集合类分为两个接口Collection和Map，其中Collection有三个子接口链表List、队列Queue、集Set，List常见的实现类为数组序列ArrayList，Queue实现类为LinkedList称为链表，Set实现类为哈希集。Collection中按照一个一个对象来存储数据，Map中按照键值对<key,value>来存储数据。\r\n\r\nCollection接口规定了ArrayList、Set等具体实现类的接口方法，例如它们都使用add()方法来添加元素，因此一些方法名在各个类实现中是通用的。\r\n4、工具类',0,4.5,'\r\nQueue<Integer> queue = new LinkedList<>();    //创建并初始化队列\r\n        queue.offer(1);     //元素入队\r\n        queue.offer(3);\r\n        queue.offer(5);\r\n        \r\n        for(int num:queue)      //遍历队列\r\n            System.out.println(num);\r\n        int pNum=queue.peek()    //获取第一个元素\r\n        int qNum=queue.poll();  //元素出队\r\n        System.out.println(qNum);\r\n',2),('1951000','第二单元','类型转换','一、自动类型转换(隐式类型转换)\r\n\r\n整型、实型(常量)、字符型数据可以混合运算。不同类型的数据先转化为同类型再进行运算\r\n\r\n自动转换按从低级到高级顺序:\r\n\r\n          char\r\n\r\n           ↓\r\n\r\nByte→short→int→long---›float→double\r\n\r\n自动转换有以下规律：\r\n\r\n小的类型自动转化为大的类型\r\n\r\n整数类型可以自动转化为浮点类型，可能会产生舍入误差\r\n\r\n1.自动类型转换(隐式转换)         \r\n\r\n小的类型自动转化为大的类型         \r\n\r\nbyte A = 70;\r\n\r\n                  int B = A + 30;\r\n\r\n                  System.out.println(B);\r\n\r\nbyte小类型转int大类型\r\n\r\n1.1自动类型转换\r\n\r\nbyte a = 0;\r\n\r\n                int b = a;\r\n\r\n                long c = a;\r\n\r\n                float d = a;\r\n\r\n                double e = a;\r\n\r\nSystem.out.println(\"b=\"+b);\r\n\r\n               System.out.println(\"c=\"+c);\r\n\r\n               System.out.println(\"d=\"+d);\r\n\r\n               System.out.println(\"e=\"+e);\r\n\r\n        从小的类型转为高的类型，byte转int,long,float,double\r\n\r\n        得出结果：0  0  0.0  0.0\r\n\r\n1.2整数类型可以自动转化为浮点类型，可能会产生舍入误差\r\n\r\n           float A = 2 + 10f;\r\n\r\n                  float B = A - 11.9f;\r\n\r\n                  System.out.println(B);\r\n\r\n           结果: 0.10000038\r\n\r\n           精准度和准确度是有差距的，float精准度的准确姓流失\r\n\r\n二、强制类型转换(显式类型转换)\r\n\r\n1.int是要强制类型转换后的数据类型\r\n\r\n强制类型转换可能导致溢出或损失精度\r\n',0,4.5,'    \r\n    int a=1;\r\n    Integer b=new Integer(2;);\r\n    a=b;\r\n    b=a;',2),('1951000','第五单元','内部类','一、什么是内部类？\r\n可以将一个类的定义放在里另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。\r\n二、为什么要用内部类？\r\n使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》\r\n\r\n也就是说内部类拥有类的基本特征。(eg：可以继承父类，实现接口。)在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。（注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，这里不推荐使用。）\r\n',0,4.5,'**\r\n 1. Outer类继承了ClassA，实现了IFunctionA\r\n*/\r\npublic class Outer extends ClassA implements IFunctionA{ \r\n	/**\r\n	*	Inner类继承了ClassB，实现了IFunctionB\r\n	*/\r\n	public class Inner extends ClassB implements IfunctionB{\r\n	//\r\n	} \r\n}\r\n',2),('1951000','第五单元','多态','多态性是面向对象程序设计代码重用的一个重要机制，我们曾不只一次的提到Java多态性。在Java运行时多态性：继承和接口的实现一文中，我们曾详细介绍了Java实现运行时多态性的动态方法调度；今天我们再次深入Java核心，一起学习Java中多态性的实现。\r\n\r\n“polymorphism(多态)”一词来自希腊语，意为“多种形式”。多数Java程序员把多态看作对象的一种能力，使其能调用正确的方法版本。尽管如此，这种面向实现的观点导致了多态的神奇功能，胜于仅仅把多态看成纯粹的概念。\r\n\r\nJava中的多态总是子类型的多态。几乎是机械式产生了一些多态的行为，使我们不去考虑其中涉及的类型问题。本文研究了一种面向类型的对象观点，分 析了如何将对象能够 表现的行为和对象即将表现的行为分离开来。抛开Java中的多态都是来自继承的概念，我们仍然可以感到，Java中的接口是一组没有公共代码的对象共享实 现。\r\n\r\n多态的分类\r\n\r\n多态在面向对象语言中是个很普遍的概念.虽然我们经常把多态混为一谈，但实际上 有四种不同类型的多态。在开始正式的子类型多态的细节讨论前，然我们先来看看普通面向对象中的多态。\r\n在这样一个体系中，多态表现出多种形式的能力。通用多态引用有 相同结构类型的大量对象，他们有着共同的特征。特定的多态涉及的是小部分没有相同特征的对象。四种多态可做以下描述：\r\n\r\n◆强制的：一种隐 式做类型转换的方法。\r\n\r\n◆重载的：将一个标志符用作多个意义。\r\n\r\n◆参数的：为不同类型的参数提供相同的操作。\r\n\r\n◆包含的：类包含关系的抽象操作。\r\n\r\n我将在讲述子类型多态前简单介绍一下这几种多态。\r\n\r\n强制的多态\r\n\r\n强制多态隐式的将参数按某种方法，转换成编译器认为正确的类型以避免错误。在以下的表达式中，编译器必须决定二元运算符‘+’所应做的工作：\r\n\r\n2.0 + 2.0\r\n\r\n2.0 + 2\r\n\r\n2.0 + \"2\"\r\n\r\n第一个表达式将两个double的 操作数相加；Java中特别声明了这种用法。\r\n\r\n第二个表达式将double型和int相加。Java中没有明确定义这种运算。不过，编 译器隐式的将第二个操作数转换为double型，并作double型的加法。做对程序员来说十分方便，否则将会抛出一个编译错误，或者强制程序员显式的将 int转换为double。\r\n\r\n第三个表达式将double与一个String相加。Java中同样没有定义这样的操作。所以，编译器将 double转换成String类型，并将他们做串联。\r\n\r\n强制多态也会发生在方法调用中。假设类Derived继承了类Base，类C 有一个方法，原型为m(Base)，在下面的代码中，编译器隐式的将Derived类的对象derived转化为Base类的对象。这种隐式的转换使 m(Base)方法使用所有能转换成Base类的所有参数。\r\n\r\nC c = new C();\r\n\r\nDerived derived = new Derived();\r\n\r\nc.m( derived );\r\n\r\n并且，隐式的强制转换，可以避免 类型转换的麻烦，减少编译错误。当然，编译器仍然会优先验证符合定义的对象类型。\r\n\r\n重载的多态\r\n\r\n重载 允许用相同的运算符或方法，去表示截然不同的意义。‘+’在上面的程序中有两个意思：两个double型的数相加；两个串相连。另外还有整型相加，长整 型，等等。这些运算符的重载，依赖于编译器根据上下文做出的选择。以往的编译器会把操作数隐式转换为完全符合操作符的类型。虽然Java明确支持重载，但 不支持用户定义的操作符重载。\r\n\r\nJava支持用户定义的函数重载。一个类中可以有相同名字的方法，这些方法可以有不同的意义。这些重载 的方法中，必须满足参数数目不同，相同位置上的参数类型不同。这些不同可以帮助编译器区分不同版本的方法。\r\n\r\n编译器以这种唯一表示的特 征来表示不同的方法，比用名字表示更为有效。据此，所有的多态行为都能编译通过。\r\n\r\n强制和重载的多态都被分类为特定的多态，因为这些多 态都是在特定的意义上的。这些被划入多态的特性给程序员带来了很大的方便。强制多态排除了麻烦的类型和编译错误。重载多态像一块糖，允许程序员用相同的名 字表示不同的方法，很方便。\r\n\r\n参数的多态\r\n\r\n参数多态允许把许多类型抽象成单一的表示。例如，List 抽象类中，描述了一组具有同样特征的对象，提供了一个通用的模板。你可以通过指定一种类型以重用这个抽象类。这些参数可以是任何用户定义的类型，大量的用 户可以使用这个抽象类，因此参数多态毫无疑问的成为最强大的多态。\r\n\r\n乍一看，上面抽象类好像是java.util.List的功能。然 而，Java实际上并不支持真正的安全类型风格的参数多态，这也是java.util.List和java.util的其他集合类是用原始的 java.lang.Object写的原因(参考我的文章\"A Primordial Interface?\" 以获得更多细节)。Java的单根继承方式解决了部分问题，但没有发挥出参数多态的全部功能。Eric Allen有一篇精彩的文章“Behold the Power of Parametric Polymorphism”，描述了Java通用类型的需求，并建议给Sun的Java规格需求#000014号文档\"Add Generic Types to the Java Programming Language.\"(参考资源链接)\r\n\r\n包含的多态\r\n\r\n包含多态通过值的类型和集合的包含关系实现了多态的行为.在包括Java在内的众多面向对象语言中，包含关系是子类型的。所以，Java的包含多态是子 类型的多态。\r\n\r\n在早期，Java开发者们所提及的多态就特指子类型的多态。通过一种面向类型的观点，我们可以看到子类型多态的强大功 能。以下的文章中我们将仔细探讨这个问题。为简明起见，下文中的多态均指包含多态。\r\n',0,4.5,'\r\nFather father=new Father（）；\r\n father.speak(); //编译时调用的是子类的，执行的也是子类的\r\n\r\nFather father=new Son（）;\r\nfather.speak();//编译时调用的是父类的，运行的确实是子类的',2),('1951000','第五单元','接口','接口概念\r\n    官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。\r\n\r\n    我的解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）\r\n\r\n \r\n\r\n接口的特点\r\n    就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。\r\n\r\n \r\n\r\n接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。\r\n一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。\r\n如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）\r\n一个JAVA库中接口的例子是：Comparator 接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。\r\n为什么要用接口\r\n    接口被用来描述一种抽象。\r\n因为Java不像C++一样支持多继承，所以Java可以通过实现接口来弥补这个局限。\r\n接口也被用来实现解耦。\r\n接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public,static的。\r\n',0,4.5,'\r\npublic interface Runner \r\n   int id = 1\r\n   public void start()\r\n   public void run()\r\n   public void stop(）    \r\n}',2),('1951000','第五单元','构造方法','\r\n1.构造方法有什么作用？\r\n构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化。\r\n换句话说：构造方法是用来创建对象，并且同时给对象的属性赋值。\r\n注意：实例变量没有手动赋值的时候，系统会赋默认值。\r\n\r\n2.构造方法怎么定义，语法是什么？\r\n[修饰符列表] 构造方法名(形式参数列表){\r\n	构造方法体;\r\n	通常在构造方法体当中给属性赋值，完成属性的初始化。\r\n}\r\n\r\n注意：\r\n\r\n第一：修饰符列表目前统一写：public。千万不要写public static。\r\n第二：构造方法名和类名必须一致。\r\n第三：构造方法不需要指定返回值类型，也不能写void，写上void表示普通方法，就不是构造方法了。\r\n普通方法的语法结构是？\r\n	[修饰符列表] 返回值类型 方法名(形式参数列表){\r\n		方法体;\r\n	}\r\n\r\n3.构造方法怎么调用，使用哪个运算符？\r\n使用new运算符来调用构造方法。\r\n\r\nnew 构造方法名(实际参数列表);\r\n1\r\n4.什么是缺省构造器？\r\n当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。\r\n这个无参数的构造方法叫做缺省构造器。\r\n\r\n5.怎么防止缺省构造器丢失？\r\n当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。\r\n建议将无参数构造方法手动的写出来，这样一定不会出问题。\r\n\r\n6.实例变量在类加载是初始化吗？实例变量在什么时候初始化？\r\n不是，实例变量是在构造方法执行的过程中完成初始化的，完成赋值的。\r\n\r\n7.构造方法支持方法重载吗？\r\n构造方法是支持方法重载的。\r\n在一个类当中构造方法可以有多个。\r\n并且所有的构造方法名字都是一样的。\r\n\r\n方法重载特点：\r\n在同一个类中，方法名相同，参数列表不同。\r\n\r\n重点\r\n对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。\r\n',0,4.5,'\r\nclass AAAA {\r\n    private int p = 10;//new的时候赋值一次\r\n\r\n    public AAAA(){\r\n        System.out.println(p);//先执行 private int p = 10在执行 System.out.println(p)\r\n        //结果：10\r\n        this.p = 910;//这里在赋值一次\r\n        System.out.println(p);\r\n        //结果：910\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new AAAA();\r\n    }\r\n}\r\n',2),('1951000','第五单元','类与对象概念','一、面向对象简述\r\n\r\n面向对象是一种现在最为流行的程序设计方法，几乎现在的所有应用都以面向对象为主了，最早的面向对象的概念实际上是由IBM提出的，在70年代的Smaltalk语言之中进行了应用，后来根据面向对象的设计思路，才形成C++，而由C++产生了Java这门面向对象的编程语言。\r\n\r\n但是在面向对象设计之前，广泛采用的是面向过程，面向过程只是针对于自己来解决问题。面向过程的操作是以程序的基本功能实现为主，实现之后就完成了，也不考虑修改的可能性，面向对象，更多的是要进行子模块化的设计，每一个模块都需要单独存在，并且可以被重复利用，所以，面向对象的开发更像是一个具备标准的开发模式。\r\n\r\n在面向对象定义之中，也规定了一些基本的特征：\r\n（1）封装：保护内部的操作不被破坏；\r\n（2）继承：在原本的基础之上继续进行扩充；\r\n（3）多态：在一个指定的范围之内进行概念的转换。\r\n\r\n对于面向对象的开发来讲也分为三个过程：OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程）。\r\n\r\n二、类与对象的基本概念\r\n\r\n类与对象时整个面向对象中最基础的组成单元。\r\n\r\n类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）；\r\n对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。\r\n\r\n可以一句话来总结出类和对象的区别：类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。\r\n',0,4.5,'\r\nclass 类名称 {\r\n         属性 (变量) ;\r\n         行为 (方法) ;\r\n}',2),('1951000','第五单元','类定义方法','类的定义\r\n\r\n类是一种引用数据类型。类为对象的模板，简单的说就是分类。类是一个模板，它描述一类对象的行为和状态。类的定义包括“成员变量”的定义和“方法”的定义，其中“成员变量”用于描述一类对象共同的数据结构。在Java语言中，类的成员变量的定义可以使用如下语法：\r\n\r\nclass 类名 {成员变量类型变量名称；………}\r\n\r\n类是用class关键字来定义的一种抽象数据类型，类不但定义了抽象数据类型的组成（成员变量），同时还定义了对该类型可以实施的操作（方法），类名的首字母必须大写。\r\n\r\n注释：1.java 会给成员变量一个初始值，但是不会给局部变量初始值，所以局部变量应赋初始值。2.局部变量与成员变量名称相同时，有限选取局部变量的值。\r\n\r\n定义的思路\r\n\r\n每个人的学习方法不同对于定义一个类的思路也可能会有所不同。一般来说我会将定义一个类分为两部分，即属性和方法（也可以说是成员变量和成员方法）。\r\n\r\n详细的说就是：\r\n\r\n1.先定义一个类；\r\n\r\n2.定义类的属性（成员变量）；\r\n\r\n3.定义类的方法；\r\n\r\n4.定义类的局部变量。\r\n\r\n例题解释\r\n\r\n例题1：设计一个圆形类，可以返回圆的面积与周长',0,4.5,'package day20190912; \r\nimport java.util.Scanner; \r\npublic class Circle {\r\n     public static void main(String[]  args) {\r\n          System.out.println(\"请输入圆的半径：\");         \r\n          Scanner input=new Scanner(System.in);\r\n          float r=input.nextFloat() ;\r\n          Circular c=new Circular();\r\n          c.area(r);\r\n          c.perimeter(r) ;\r\n     } \r\n}\r\nclass Circular{\r\n     //1.成员变量：半径\r\n     private float r;\r\n     //2.成员方法：计算圆的周长和面积\r\n     public void perimeter(float r){\r\n         //周长等于3.14*2*r\r\n         System.out.println(\"周长为\"+(3.14*2*r));\r\n     }\r\n     public void area(float r){\r\n         //面积等于3.14*r*r\r\n         System.out.println(\"面积为\"+(3.14*r*r));\r\n     } \r\n}\r\n',2),('1951000','第五单元','继承','继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。\r\n\r\n在Java之中，如果要实现继承的关系，可以使用如下的语法：\r\n\r\nclass 子类 extends 父类 {}',0,4.5,'package com.wz.extendsdemo;\r\n\r\nclass Person {\r\n    private String name;\r\n    private int age;\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return this.age;\r\n    }\r\n}\r\n\r\nclass Student extends Person { // Student类继承了Person类\r\n}\r\n\r\npublic class TestDemo {\r\n    public static void main(String args[]) {\r\n        Student stu = new Student(); // 实例化的是子类\r\n        stu.setName(\"张三\"); // Person类定义\r\n        stu.setAge(20); // Person类定义\r\n        System.out.println(\"姓名：\" + stu.getName() + \"，年龄：\" + stu.getAge());\r\n    }\r\n}\r\n',2),('1951000','第四单元','Vector类','Vector 可实现自动增长的对象数组。\r\njava.util.vector提供了向量类(vector)以实现类似动态数组的功能。在Java语言中没有指针的概念，但如果正确灵活地使用指针又确实可以大大提高程序的质量。比如在c,c++中所谓的“动态数组”一般都由指针来实现。为了弥补这个缺点，Java提供了丰富的类库来方便编程者使用，vector类便是其中之一。事实上，灵活使用数组也可以完成向量类的功能，但向量类中提供大量的方法大大方便了用户的使用。\r\n创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况。可以考虑使用向量类。\r\n\r\n向量类提供了三种构造方法：\r\npublic vector()\r\npublic vector(int initialcapacity,int capacityIncrement)\r\npublic vector(int initialcapacity)\r\n\r\n使用第一种方法系统会自动对向量进行管理，若使用后两种方法。则系统将根据参数，initialcapacity设定向量对象的容量（即向量对象可存储数据的大小），当真正存放的数据个数超过容量时。系统会扩充向量对象存储容量。\r\n\r\n参数capacityincrement给定了每次扩充的扩充值。当capacityincrement为0的时候，则没次扩充一倍，利用这个功能可以优化存储。在Vector类中提供了各种方法方便用户的使用：\r\n\r\n插入功能：\r\n（1）public final synchronized void adddElement(Object obj)\r\n将obj插入向量的尾部。obj可以是任何类型的对象。对同一个向量对象，亦可以在其中插入不同类的对象。但插入的应是对象而不是数值，所以插入数值时要注意将数组转换成相应的对象。\r\n例如：要插入整数1时，不要直接调用v1.addElement(1),正确的方法为：\r\nVector v1 = new Vector();\r\nInteger integer1 = new Integer(1);\r\nv1.addElement(integer1);\r\n(2)public final synchronized void setElementAt(Object obj,int index)\r\n将index处的对象设置成obj，原来的对象将被覆盖。\r\n(3)public final synchronized void insertElement(Object obj,int index)\r\n在index指定的位置插入obj，原来对象以及此后的对象依次往后顺延。\r\n\r\n删除功能：\r\n(1)public final synchronized void removeElement(Object obj)\r\n从向量中删除obj,若有多个存在，则从向量头开始试，删除找到的第一个与obj相同的向量成员。\r\n(2)public final synchronized void removeAllElement();\r\n删除向量所有的对象\r\n(3)public fianl synchronized void removeElementAt(int index)\r\n删除index所指的地方的对象\r\n\r\n查询搜索功能：\r\n(1)public final int indexOf(Object obj)\r\n从向量头开始搜索obj,返回所遇到的第一个obj对应的下标，若不存在此obj,返回-1.\r\n(2)public final synchronized int indexOf(Object obj,int index)\r\n从index所表示的下标处开始搜索obj.\r\n(3)public final int lastindexOf(Object obj)\r\n从向量尾部开始逆向搜索obj.\r\n(4)public final synchornized int lastIndex(Object obj,int index)\r\n从index所表示的下标处由尾至头逆向搜索obj.\r\n(5)public final synchornized firstElement()\r\n获取向量对象中的首个obj\r\n(6)public final synchornized Object lastElement()\r\n获取向量对象的最后一个obj\r\n\r\n例子：VectorApp.java\r\nimport java.util.Vector;\r\nimport java.lang.*;\r\nimport java.util.Enumeration;\r\npublic class VectorApp\r\n{\r\npublic static void main(String args[])\r\n{\r\nVector v1 = new Vector();\r\nInteger integer1= new Integer(1);\r\n//加入为字符串对象\r\nv1.addElement(\"one\");\r\n//加入的为integer的对象\r\nv1.addElement(integer1);\r\nv1.addElement(integer1);\r\nv1.addElement(\"two\");\r\nv1.addElement(new Integer(2));\r\nv1.addElement(integer1);\r\nv1.addElement(integer1);\r\n//转为字符串并打印\r\nSystem.out.println(\"The Vector v1 is:\\n\\t\"+v1);\r\n//向指定位置插入新对象\r\nv1.insertElement(\"three\",2);\r\nv1.insertElement(new Float(3.9),3);\r\nSystem.out.println(\"The Vector v1(used method\r\ninsertElementAt()is:\\n\\t)\"+v1);\r\n//将指定位置的对象设置为新的对象\r\n//指定位置后的对象依次往后顺延\r\nv1.setElementAt(\"four\",2);\r\nSystem.out.println(\"The vector v1 cused method setElmentAt()is:\\n\\t\"+v1);\r\nv1.removeElement(integer1);\r\n//从向量对象v1中删除对象integer1\r\n//由于存在多个integer1,所以从头开始。\r\n//找删除找到的第一个integer1.\r\nEnumeration enum = v1.elements();\r\nSystem.out.println(\"The vector v1 (used method removeElememt()is\");\r\nwhile(enum.hasMoreElements())\r\nSystem.out.println(enum.nextElement()+\"\");\r\nSystem.out.println();\r\n//使用枚举类(Enumeration)的方法取得向量对象的每个元素。\r\nSystem.out.println(\"The position of Object1(top-to-botton):\"+v1.indexOf(integer1));\r\nSystem.out.println(\"The position of Object1(tottom-to-top):\"+v1.lastIndexOf(integer1));\r\n//按不同的方向查找对象integer1所处的位置\r\nv1.setSize(4);\r\nSystem.out.println(\"The new Vector(resized the vector)is:\"+v1);\r\n//重新设置v1的大小，多余的元素被抛弃\r\n}\r\n}\r\n\r\n运行结果：\r\nE:\\java01>java VectorApp\r\nThe vector v1 is:[one,1,1,two,2,1,1]\r\nThe vector v1(used method insetElementAt()) is:\r\n[one,1,three,3.9,1,two,2,1,1]\r\nThe vector v1(used method setElementAt()) is:\r\n[one,1,four,3.9,1,two,2,1,1]\r\nThe vector v1(useed method removeElement()) is:\r\none four 3.9 1 two 2 1 1\r\nThe position of object1(top-to-botton):3\r\nThe position of object1(botton-to-top):7\r\nThe new Vector(resized the vector) is:\r\n[one,four,3.9,1]\r\n\r\n(1)类vector定义了方法\r\npublic final int size();\r\n此方法用于获取向量元素的个数。它们返回值是向量中实际存在的元素个数，而非向量容量。可以调用方法capacity()来获取容量值。\r\n\r\n方法：\r\npublic final synchronized void setsize(int newsize);\r\n此方法用来定义向量的大小，若向量对象现有成员个数已经超过了newsize的值，则超过部分的多余元素会丢失。\r\n(2)程序中定义Enumeration类的一个对象Enumeration是java.util中的一个接口类，\r\n在Enumeration中封装了有关枚举数据集合的方法。\r\n在Enumeration提供了方法hasMoreElement()来判断集合中是否还有其他元素和方法nextElement()来判断集合中是否还有其他元素和方法nextElement()来获取下一个元素。利用这两个方法，可以依次获得集合中的元素。\r\nVector中提供方法：\r\npublic final synchronized Enumeration elements();\r\n此方法将向量对象对应到一个枚举类型。java.util包中的其他类中也都有这类方法，以便于用户获取对应的枚举类型。\r\n',0,4.5,'\r\nimport java.util.Vector; \r\nimport java.lang.*; \r\nimport java.util.Enumeration; \r\npublic class VectorApp \r\n{ \r\n     public static void main(String args[]) \r\n     { \r\n          Vector v1 = new Vector(); \r\n          Integer integer1= new Integer(1); \r\n          //加入为字符串对象 \r\n          v1.addElement(\"one\"); \r\n          //加入的为integer的对象 \r\n          v1.addElement(integer1); \r\n          v1.addElement(integer1); \r\n          v1.addElement(\"two\"); \r\n          v1.addElement(new Integer(2)); \r\n          v1.addElement(integer1); \r\n          v1.addElement(integer1); \r\n          //转为字符串并打印 \r\n            System.out.println(\"The Vector v1 is:\\n\\t\"+v1); \r\n          //向指定位置插入新对象 \r\n          v1.insertElement(\"three\",2); \r\n          v1.insertElement(new Float(3.9),3); \r\n          System.out.println(\"The Vector v1(used method \r\n          insertElementAt()is:\\n\\t)\"+v1); \r\n          //将指定位置的对象设置为新的对象 \r\n            //指定位置后的对象依次往后顺延 \r\n            v1.setElementAt(\"four\",2); \r\n           System.out.println(\"The vector v1 cused method setElmentAt()is:\\n\\t\"+v1); \r\n           v1.removeElement(integer1); \r\n           //从向量对象v1中删除对象integer1 \r\n           //由于存在多个integer1,所以从头开始。 \r\n             //找删除找到的第一个integer1. \r\n           Enumeration enum = v1.elements(); \r\n           System.out.println(\"The vector v1 (used method removeElememt()is\"); \r\n            while(enum.hasMoreElements()) \r\n            System.out.println(enum.nextElement()+\"\"); \r\n            System.out.println(); \r\n            //使用枚举类(Enumeration)的方法取得向量对象的每个元素。 \r\n              System.out.println(\"The position of Object1(top-to-botton):\"+v1.indexOf(integer1)); \r\n            System.out.println(\"The position of Object1(tottom-to-top):\"+v1.lastIndexOf(integer1)); \r\n            //按不同的方向查找对象integer1所处的位置 \r\n              v1.setSize(4); \r\n            System.out.println(\"The new Vector(resized the vector)is:\"+v1); \r\n            //重新设置v1的大小，多余的元素被抛弃    \r\n     } \r\n} \r\n',2),('1951000','第四单元','字符串类型','Java 字符串类主要有String、StringBuffer、StringBuilder\r\n\r\n相同点：\r\n都可以对字符串进行操作，底层都是基于char[]进行操作的\r\n\r\n\r\n不同点：\r\n1.String的操作都会产生一个新的对象，StringBuffer、StringBuilder基于原字符串进行修改\r\n2.实例化不同String可以利用构造函数的方式对其进行初始化，也可以用赋值的方式。StringBuffer、StringBuilder只能使用构造函数的方式对其进行初始化，使用append()进行拼接\r\n3.StringBuffer中的方法都采用了synchronized关键词进行修饰，提供线程同步，安全。而StringBuilder没有这个修饰，线程不安全安全。\r\n\r\n4.单线程下，StringBuffer效率更快，因为它不需要加锁，不具备多线程安全。\r\n\r\n\r\n使用情况\r\nString：数据量较小时，优先使用\r\nStringBuffer 多线程操作大量数据时使用\r\nStringBuilder 单线程操作大量数据时使用\r\n',0,4.5,'\r\npublic class stringType {\r\n    public static void main(String[] args) {\r\n        \r\n        //实例化不同String可以利用构造函数的方式对其进行初始化，也可以用赋值的方式。\r\n        //StringBuffer、StringBuilder只能使用构造函数的方式对其进行初始化\r\n        String s=new String(\"Hello,\");\r\n        s=s+\"Wold\";\r\n        String s1=\"Hello Word\";\r\n \r\n        StringBuilder s2=new StringBuilder(\"Hello,\");\r\n        s2.append(\"Word\");\r\n \r\n        StringBuffer s3=new StringBuffer(\"Hello,\");\r\n        s3.append(\"Word\");\r\n        System.out.println(\"s=\"+s+\",s1=\"+s1+\",s2=\"+s2+\",s3=\"+s3);\r\n    }\r\n}\r\n\r\n',2),('1951000','第四单元','数组','数组的基本概念\r\n如果说现在要求你定义100个整型变量，那么如果按照之前的做法，可能现在定义的的结构如下：\r\n\r\nint i1, i2, i3, ... i100;\r\n1\r\n但是这个时候如果按照此类方式定义就会非常麻烦，因为这些变量彼此之间没有任何的关联，也就是说如果现在突然再有一个要求，要求你输出这100个变量的内容，意味着你要编写System.out.println()语句100次。\r\n\r\n其实所谓的数组指的就是一组相关类型的变量集合，并且这些变量可以按照统一的方式进行操作。数组本身属于引用数据类型，那么既然是引用数据类型，这里面实际又会牵扯到内存分配，而数组的定义语法有如下两类。\r\n\r\n数组动态初始化：\r\n声明并开辟数组：\r\n数据类型 [] 数组名称 = new 数据类型[长度];\r\n数据类型 [] 数组名称 = new 数据类型[长度];\r\n分布进行数组空间开辟（实例化）\r\n| Tables | Are |\r\n| ------------- |:-------------?\r\n| 声明数组： | 数组类型 数组名称[] = null; | | | 数组类型 [] 数组名称 =null; | | 开辟数组空间： | 数组名称 =new` 数组类型[长度]; |\r\n那么当数组开辟空间之后，就可以采用如下的方式的操作：\r\n\r\n数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，所以索引的范围就是0 ~ 数组长度-1，例如开辟了3个空间的数组，所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，会产生java.lang.ArrayIndexOutOfBoundsException 异常信息；\r\n当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；\r\n数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用 for 循环。\r\n在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；\r\n数组引用传递\r\n数组静态初始化\r\n在之前所进行的数组定义都有一个明显特点：数组先开辟内存空间，而后再使用索引进行内容的设置，实际上这种做法都叫做动态初始化，而如果希望数组在定义的时候可以同时出现设置内容，那么就可以采用静态初始化完成。',0,4.5,'\r\nublic class ArrayDemo {\r\n	public static void main(String args[]) {\r\n		int data[] = {1, 2, 4, 545, 11, 32, 13131, 4444};\r\n		for(int i = 0; i < data.length; i++) {\r\n			System.out.println(data[i]);\r\n		}\r\n	}\r\n}\r\n\r\npublic class ArrayDemo {\r\n	public static void main(String args[]) {\r\n		//此时的数组并不是一个等列数组\r\n		int data[][] = new int[][] {\r\n			{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};\r\n		//如果在进行输出的时候一定要使用双重循环，\r\n		//外部的循环控制输出的行数，而内部的循环控制输出列数\r\n		for(int i = 0; i < data.length; i++) {\r\n			for(int j = 0; j < data[i].length; j++) {\r\n				System.out.print(\"data[\" + i + \"][\" + j + \"]=\" + data[i][j] + \"、\");\r\n			}\r\n			System.out.println();\r\n		}\r\n	}\r\n}\r\n\r\n',2);

/*Table structure for table `tablenote` */

DROP TABLE IF EXISTS `tablenote`;

CREATE TABLE `tablenote` (
  `notetitle` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `unit` varchar(20) DEFAULT NULL,
  `time` date DEFAULT NULL,
  `content` varchar(10000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `id` varchar(50) DEFAULT NULL,
  `abstract1` varchar(5000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;

/*Data for the table `tablenote` */

insert  into `tablenote`(`notetitle`,`unit`,`time`,`content`,`id`,`abstract1`) values ('Java 基础语法','第一单元','2021-11-12','一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。','1951000','一个简单的 Java 程序'),('Java 对象和类','第四单元','2021-11-13','对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。','1951000','类可以看成是创建 Java 对象的模板'),('Java 运算符','第二单元','2021-11-15','从效率方面来说，&&比&的效率高一些。','1951000','短路与&& 和 逻辑与 &有什么区别');

/*Table structure for table `tablerely` */

DROP TABLE IF EXISTS `tablerely`;

CREATE TABLE `tablerely` (
  `id` varchar(20) DEFAULT NULL,
  `old` varchar(100) DEFAULT NULL,
  `rely` varchar(100) DEFAULT NULL,
  `relyid` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`relyid`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tablerely` */

insert  into `tablerely`(`id`,`old`,`rely`,`relyid`) values ('1951000','java基本语法','java变量',1),('1951000','java编译与运行','java语言特点',2);

/*Table structure for table `tableteacher` */

DROP TABLE IF EXISTS `tableteacher`;

CREATE TABLE `tableteacher` (
  `id` varchar(20) NOT NULL,
  `password` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tableteacher` */

insert  into `tableteacher`(`id`,`password`) values ('10000','123456');

/*Table structure for table `tabletest` */

DROP TABLE IF EXISTS `tabletest`;

CREATE TABLE `tabletest` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `teststate` int DEFAULT NULL,
  `qcount` int DEFAULT NULL,
  `unittitle` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  `score` float DEFAULT '0',
  `data` datetime DEFAULT NULL,
  PRIMARY KEY (`id`,`unit`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tabletest` */

insert  into `tabletest`(`id`,`unit`,`teststate`,`qcount`,`unittitle`,`score`,`data`) values ('1951000','第一单元',1,65,'概述',85,'2021-12-17 12:48:51'),('1951000','第三单元',0,65,'表达式和流程控制语句',0,'2021-12-16 02:11:26'),('1951000','第二单元',1,65,'标识符和数据类型',74,'2021-12-16 02:11:26'),('1951000','第五单元',0,65,'进一步讨论对象和类',0,'2021-12-16 02:11:26'),('1951000','第四单元',0,65,'数组、向量和字符串',0,'2021-12-16 02:11:26');

/*Table structure for table `tableunit` */

DROP TABLE IF EXISTS `tableunit`;

CREATE TABLE `tableunit` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `allpoint` int DEFAULT NULL,
  `finishpoint` int DEFAULT NULL,
  `finishstate` int DEFAULT NULL,
  `unit` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `unittitle` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`,`unit`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tableunit` */

insert  into `tableunit`(`id`,`allpoint`,`finishpoint`,`finishstate`,`unit`,`unittitle`) values ('1951000',6,2,0,'第一单元','概述'),('1951000',6,0,0,'第三单元','表达式和流程控制语句'),('1951000',5,0,0,'第二单元','标识符和数据类型'),('1951000',7,0,0,'第五单元','进一步讨论对象和类'),('1951000',3,0,0,'第四单元','数组、向量和字符串');

/*Table structure for table `tableuser` */

DROP TABLE IF EXISTS `tableuser`;

CREATE TABLE `tableuser` (
  `username` char(20) DEFAULT NULL,
  `password` char(20) DEFAULT NULL,
  `email` char(20) DEFAULT NULL,
  `phone` char(20) DEFAULT NULL,
  `id` char(20) DEFAULT NULL,
  `speciality` char(20) DEFAULT NULL,
  `learnrate` float DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tableuser` */

insert  into `tableuser`(`username`,`password`,`email`,`phone`,`id`,`speciality`,`learnrate`) values ('小红','123456','1234568@qq.com','123456','1951001','环境工程564',0),('小王','123456','3456789@qq.com','456789','1951002','地质工程',0),(NULL,NULL,NULL,NULL,NULL,NULL,0),('小明','123456','1234567@qq.com','13422971621','1951000','信息管理',79.5),('werw','1','456@qq.com','46554688','456321','jkjksd',0),('op','2','2905703741@qq.com','13422971621','15996','sxa',0);

/*Table structure for table `tableuserlearn` */

DROP TABLE IF EXISTS `tableuserlearn`;

CREATE TABLE `tableuserlearn` (
  `id` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `allunit` int DEFAULT NULL,
  `finishunit` int DEFAULT NULL,
  `tag1` int DEFAULT '0',
  `tag2` int DEFAULT '0',
  `tag3` int DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

/*Data for the table `tableuserlearn` */

insert  into `tableuserlearn`(`id`,`allunit`,`finishunit`,`tag1`,`tag2`,`tag3`) values ('1951000',5,0,5,0,1);

/* Trigger structure for table `tableunit` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `after_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `after_insert` AFTER INSERT ON `tableunit` FOR EACH ROW BEGIN
	UPDATE tableuserlearn SET allunit =allunit+1 WHERE tableuserlearn.`id`=new.id;
    END */$$


DELIMITER ;

/* Trigger structure for table `tableunit` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `updateGoods` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `updateGoods` AFTER UPDATE ON `tableunit` FOR EACH ROW BEGIN
        UPDATE tableuserlearn set tableuserlearn.`finishunit`=(SELECT COUNT(*) FROM tableunit WHERE tableunit.`id`=new.id AND tableunit.`finishstate`=1) where tableuserlearn.`id`=new.id;
    END */$$


DELIMITER ;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
